This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.log
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.gitignore
Dockerfile
list_tables.sql
package.json
prisma.config.js
prisma.config.ts.disabled
prisma/client.js
prisma/client.ts
prisma/migrations/20260119_baseline_v1/migration.sql
prisma/migrations/20260120_bolao_invites/migration.sql
prisma/migrations/20260120_bolao_ranking_model/migration.sql
prisma/migrations/20260120_monetizacao_core/migration.sql
prisma/migrations/20260120_snapshot_ranking_v1_2/migration.sql
prisma/migrations/20260122_v1_5_subscription_recorrente/migration.sql
prisma/migrations/20260123_add_payment_webhook_events/migration.sql
prisma/migrations/20260123_v1_5_subscription_recorrente_mp/migration.sql
prisma/migrations/20260131_add_payment_packages/migration.sql
prisma/schema.prisma
prisma/seed.js
src/audit/audit.repository.ts
src/audit/audit.service.ts
src/controllers/admin-subscriptions.controller.ts
src/controllers/admin/admin-billing-metrics.controller.ts
src/controllers/admin/admin-monetization.controller.ts
src/controllers/admin/admin-subscriptions.controller.ts
src/controllers/admin/monetization.controller.ts
src/controllers/bolao/bolao-ranking.controller.ts
src/controllers/bolao/create-bolao-invite.controller.ts
src/controllers/bolao/use-bolao-invite.controller.ts
src/controllers/internal-jobs.controller.ts
src/controllers/internal/alerts-jobs.controller.ts
src/controllers/internal/close-expired-rankings.controller.ts
src/controllers/internal/generate-ranking-snapshot.controller.ts
src/controllers/internal/mercado-pago-subscription.controller.ts
src/controllers/internal/mercado-pago-webhook.controller.ts
src/controllers/internal/score-round.job.controller.ts
src/controllers/internal/subscription-jobs.controller.ts
src/controllers/me.controller.ts
src/controllers/payment.controller.ts
src/controllers/PaymentsHistoryController.ts
src/controllers/ranking.controller.ts
src/controllers/ranking/monthly-ranking.controller.ts
src/controllers/ranking/semester-ranking.controller.ts
src/controllers/ranking/weekly-ranking.controller.ts
src/controllers/ticket.controller.ts
src/controllers/user.controller.ts
src/domain/payment-packages.ts
src/domain/permissions.ts
src/errors/AppError.ts
src/index.ts
src/lib/mercado-pago.client.ts
src/lib/prisma.ts
src/middleware/auth.ts
src/middleware/error-handler.ts
src/middleware/internal-job-auth.middleware.ts
src/middleware/internalJobAuth.ts
src/middleware/require-admin.middleware.ts
src/middleware/requirePermission.ts
src/middleware/requireRole.ts
src/repositories/ranking.repository.ts
src/repositories/round.repository.ts
src/repositories/ticket.repository.ts
src/repositories/user-score-history.repository.ts
src/repositories/user.repository.ts
src/routes/admin-monetization.routes.ts
src/routes/admin-subscriptions.routes.ts
src/routes/auth.ts
src/routes/health.ts
src/routes/index.ts
src/routes/internal-jobs.routes.ts
src/routes/internal.routes.ts
src/routes/internal/index.ts
src/routes/internal/jobs.routes.ts
src/routes/internal/mercado-pago.routes.ts
src/routes/internal/subscription-jobs.routes.ts
src/routes/internal/webhooks.routes.ts
src/routes/me.ts
src/routes/payment-packages.routes.ts
src/routes/payment.routes.ts
src/routes/ranking.routes.ts
src/routes/ticket.routes.ts
src/routes/user.routes.ts
src/services/admin/admin-benefits-paid.service.ts
src/services/admin/admin-benefits.service.ts
src/services/admin/admin-billing-metrics.service.ts
src/services/admin/admin-bolao.service.ts
src/services/admin/admin-ledger.service.ts
src/services/admin/admin-role.service.ts
src/services/admin/admin-subscription.service.ts
src/services/admin/admin-wallet-credit.service.ts
src/services/admin/admin-wallet.service.ts
src/services/admin/cancel-subscription.service.ts
src/services/admin/get-admin-subscription.service.ts
src/services/admin/get-subscription.service.ts
src/services/admin/list-admin-subscriptions.service.ts
src/services/admin/list-subscriptions.service.ts
src/services/alerts/detect-job-anomalies.service.ts
src/services/alerts/detect-payment-anomalies.service.ts
src/services/alerts/detect-subscription-anomalies.service.ts
src/services/alerts/detect-webhook-anomalies.service.ts
src/services/benefits/consume-benefits.service.ts
src/services/benefits/round-benefit.service.ts
src/services/bolao/create-bolao-invite.service.ts
src/services/bolao/create-bolao.service.ts
src/services/bolao/get-bolao-ranking.service.ts
src/services/bolao/join-bolao.controller.ts
src/services/bolao/join-bolao.service.ts
src/services/bolao/use-bolao-invite.service.ts
src/services/payment/create-payment.service.ts
src/services/payment/list-payment-history.service.ts
src/services/payment/process-mercado-pago-webhook.service.ts
src/services/ranking/add-participant.service.ts
src/services/ranking/assert-can-add-participant.service.ts
src/services/ranking/calculate-ranking.service.ts
src/services/ranking/close-expired-rankings.service.ts
src/services/ranking/close-ranking.service.ts
src/services/ranking/CloseRankingService.ts
src/services/ranking/create-ranking.service.ts
src/services/ranking/get-monthly-ranking.service.ts
src/services/ranking/get-ranking.service.ts
src/services/ranking/get-semester-ranking.service.ts
src/services/ranking/get-weekly-ranking.service.ts
src/services/ranking/persist-ranking.service.ts
src/services/ranking/snapshot-ranking.service.ts
src/services/round/close-round.service.ts
src/services/round/create-round.service.ts
src/services/round/open-round.service.ts
src/services/round/score-round.service.ts
src/services/score/calculate-ticket-score.service.ts
src/services/score/score-round.service.ts
src/services/subscription/activate-pro-from-payment.service.ts
src/services/subscription/process-mp-subscription-cancelled.service.ts
src/services/subscription/process-mp-subscription-created.service.ts
src/services/subscription/process-mp-subscription-updated.service.ts
src/services/subscription/renew-subscription-from-payment.service.ts
src/services/subscription/revalidate-active-subscriptions.service.ts
src/services/subscription/subscription.service.ts
src/services/ticket/create-ticket.service.ts
src/services/user-profile.service.ts
src/services/user.service.ts
src/services/wallet/wallet.service.ts
src/utils/jwt.ts
src/validators/createUser.validator.ts
tsc
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/controllers/PaymentsHistoryController.ts">
import { Request, Response } from 'express'
import { ListPaymentHistoryService } from '../services/payment/list-payment-history.service'

/**
 * PaymentsHistoryController
 *
 * Respons√°vel exclusivamente por:
 * - Expor o hist√≥rico de pagamentos do usu√°rio autenticado
 *
 * Regras:
 * - Usu√°rio DEVE estar autenticado
 * - Nenhuma l√≥gica de neg√≥cio aqui
 * - Apenas orquestra request ‚Üí service ‚Üí response
 */
export class PaymentsHistoryController {
  static async history(req: Request, res: Response) {
    const userId = (req as any).user?.id

    if (!userId) {
      return res.status(401).json({ message: 'Unauthorized' })
    }

    const history = await ListPaymentHistoryService.execute(userId)

    return res.status(200).json(history)
  }
}
</file>

<file path="tsc">
0,317
</file>

<file path="list_tables.sql">
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'public'
ORDER BY table_name;
</file>

<file path="prisma.config.js">
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
require("dotenv/config");
const config_1 = require("prisma/config");
exports.default = (0, config_1.defineConfig)({
    schema: "prisma/schema.prisma",
    migrations: {
        path: "prisma/migrations",
    },
    datasource: {
        url: process.env["DATABASE_URL"],
    },
});
</file>

<file path="prisma.config.ts.disabled">
// This file was generated by Prisma, and assumes you have installed the following:
// npm install --save-dev prisma dotenv
import "dotenv/config";
import { defineConfig } from "prisma/config";

export default defineConfig({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations",
  },
  datasource: {
    url: process.env["DATABASE_URL"],
  },
});
</file>

<file path="prisma/client.js">
"use strict";
</file>

<file path="prisma/client.ts">

</file>

<file path="prisma/migrations/20260119_baseline_v1/migration.sql">
-- Baseline migration
-- Existing production database
-- No changes applied
</file>

<file path="prisma/migrations/20260123_add_payment_webhook_events/migration.sql">
-- CreateTable
CREATE TABLE "payment_webhook_events" (
  "id" TEXT NOT NULL,
  "provider" TEXT NOT NULL,
  "externalEventId" TEXT NOT NULL,
  "payload" JSONB NOT NULL,
  "receivedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT "payment_webhook_events_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "payment_webhook_events_provider_externalEventId_key"
ON "payment_webhook_events"("provider", "externalEventId");
</file>

<file path="prisma/migrations/20260123_v1_5_subscription_recorrente_mp/migration.sql">
-- v1.5 Subscription Recorrente (Mercado Pago)
-- Migration incremental controlada (sem migrate dev)

ALTER TABLE "subscriptions"
ADD COLUMN IF NOT EXISTS "provider" "PaymentProvider",
ADD COLUMN IF NOT EXISTS "externalSubscriptionId" TEXT,
ADD COLUMN IF NOT EXISTS "externalCustomerId" TEXT;
</file>

<file path="prisma/migrations/20260131_add_payment_packages/migration.sql">
CREATE TABLE "PaymentPackage" (
  "id" TEXT NOT NULL,
  "label" TEXT NOT NULL,
  "coinsAmount" INTEGER NOT NULL,
  "amountCents" INTEGER NOT NULL,
  "bonusCoins" INTEGER NOT NULL DEFAULT 0,
  "isActive" BOOLEAN NOT NULL DEFAULT true,
  "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT "PaymentPackage_pkey" PRIMARY KEY ("id")
);
</file>

<file path="prisma/seed.js">
const { PrismaClient } = require('@prisma/client');
const bcrypt = require('bcryptjs');

const prisma = new PrismaClient();

async function main() {
  const passwordHash = await bcrypt.hash('123456', 10);

  await prisma.user.create({
    data: {
      name: 'Admin',
      email: 'admin@fantasy12.com',
      password: passwordHash,
      role: 'ADMIN',
    },
  });

  console.log('Seed executado com sucesso');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
</file>

<file path="src/audit/audit.repository.ts">
import { prisma } from '../lib/prisma';

interface CreateAuditLogData {
  userId: string;
  action: string;
  entity: string;
  entityId?: string;
  metadata?: any;
  ipAddress?: string;
  userAgent?: string;
}

interface LogAuditData {
  userId: string;
  action: string;
  metadata?: any;
  entity?: string;
  entityId?: string;
  ipAddress?: string;
  userAgent?: string;
}

export class AuditRepository {
  // M√©todo log (usado pelo service)
  async log(data: LogAuditData) {
    return prisma.auditLog.create({
      data: {
        userId: data.userId,
        action: data.action,
        entity: data.entity || 'SYSTEM',  // Default se n√£o passar
        entityId: data.entityId,
        metadata: data.metadata,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent
      }
    });
  }

  // M√©todo create (alias para log)
  async create(data: CreateAuditLogData) {
    return this.log(data);
  }

  async findMany(filters?: {
    userId?: string;
    entity?: string;
    limit?: number;
  }) {
    return prisma.auditLog.findMany({
      where: {
        userId: filters?.userId,
        entity: filters?.entity
      },
      orderBy: {
        createdAt: 'desc'
      },
      take: filters?.limit || 100,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }

  async findById(id: string) {
    return prisma.auditLog.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });
  }
}
</file>

<file path="src/audit/audit.service.ts">
import { AuditRepository } from './audit.repository';

export class AuditService {
  private repo = new AuditRepository();

  async logAccess(userId: string, action: string, metadata?: any) {
    return this.repo.log({ userId, action, metadata });
  }
}
</file>

<file path="src/controllers/admin-subscriptions.controller.ts">

</file>

<file path="src/controllers/admin/admin-billing-metrics.controller.ts">
import { Request, Response } from 'express';
import { AdminBillingMetricsService } from '../../services/admin/admin-billing-metrics.service';

/**
 * Controller ‚Äî Painel ADMIN | M√©tricas de Billing
 *
 * RESPONSABILIDADES:
 * - Orquestrar service
 * - Nenhuma regra de neg√≥cio
 * - Somente leitura
 *
 * BLOCO:
 * - v1.8 ‚Äî M√©tricas de Billing
 */
export class AdminBillingMetricsController {
  /**
   * GET /api/admin/billing/metrics
   */
  static async getMetrics(_req: Request, res: Response): Promise<Response> {
    const metrics = await AdminBillingMetricsService.execute();
    return res.status(200).json(metrics);
  }
}
</file>

<file path="src/controllers/admin/admin-monetization.controller.ts">
import { Request, Response } from 'express';
import { AdminWalletService } from '../../services/admin/admin-wallet.service';
import { AdminLedgerService } from '../../services/admin/admin-ledger.service';
import { AdminSubscriptionService } from '../../services/admin/admin-subscription.service';
import { AdminWalletCreditService } from '../../services/admin/admin-wallet-credit.service';
import { AdminRoleService } from '../../services/admin/admin-role.service';
import { AdminBenefitsService } from '../../services/admin/admin-benefits.service';
import { AdminPaidBenefitsService } from '../../services/admin/admin-benefits-paid.service';
import { AdminBolaoService } from '../../services/admin/admin-bolao.service';

export class AdminMonetizationController {
  static wallet(req: Request, res: Response) {
    return AdminWalletService.getWalletByUser(req.params.userId)
      .then(res.json.bind(res));
  }

  static ledger(req: Request, res: Response) {
    return AdminLedgerService.listByUser(req.params.userId)
      .then(res.json.bind(res));
  }

  static subscriptions(req: Request, res: Response) {
    return AdminSubscriptionService.getByUser(req.params.userId)
      .then(res.json.bind(res));
  }

  static setRole(req: Request, res: Response) {
    const adminId = (req as any).user.id;
    const { role } = req.body;

    return AdminRoleService.setRole(adminId, req.params.userId, role)
      .then(res.json.bind(res));
  }

  static creditCoins(req: Request, res: Response) {
    const adminId = (req as any).user.id;
    const { amount, reason } = req.body;

    return AdminWalletCreditService.credit(
      adminId,
      req.params.userId,
      amount,
      reason
    ).then(res.json.bind(res));
  }

  static creditFree(req: Request, res: Response) {
    const adminId = (req as any).user.id;
    const { roundId, type, amount } = req.body;

    return AdminBenefitsService.creditFree(
      adminId,
      req.params.userId,
      roundId,
      type,
      amount
    ).then(res.json.bind(res));
  }

  static creditPaid(req: Request, res: Response) {
    const adminId = (req as any).user.id;
    const { type, amount } = req.body;

    return AdminPaidBenefitsService.creditPaid(
      adminId,
      req.params.userId,
      amount,
      type
    ).then(res.json.bind(res));
  }

  static createBolao(req: Request, res: Response) {
    const adminId = (req as any).user.id;
    return AdminBolaoService.create(adminId, req.body)
      .then(res.json.bind(res));
  }
}
</file>

<file path="src/controllers/admin/admin-subscriptions.controller.ts">
import { Request, Response } from 'express';
import {
  SubscriptionStatus,
  SubscriptionPlan,
  PaymentProvider,
} from '@prisma/client';
import { ListAdminSubscriptionsService } from '../../services/admin/list-admin-subscriptions.service';

/**
 * Controller ‚Äî Painel ADMIN | Assinaturas
 *
 * RESPONSABILIDADES:
 * - Validar entrada
 * - Orquestrar services
 * - Nenhuma regra de neg√≥cio
 *
 * BLOCO:
 * - v1.6 ‚Äî Painel ADMIN de Assinaturas
 */
export class AdminSubscriptionsController {
  /**
   * GET /api/admin/subscriptions
   */
  static async list(req: Request, res: Response): Promise<Response> {
    const { page, limit, status, plan, provider, userId } = req.query;

    /**
     * üßÆ Pagina√ß√£o segura
     */
    const parsedPage =
      typeof page === 'string' && Number(page) > 0
        ? Number(page)
        : undefined;

    const parsedLimit =
      typeof limit === 'string' && Number(limit) > 0
        ? Number(limit)
        : undefined;

    /**
     * üîé Filtros tipados (ALINHADOS AO SCHEMA)
     */
    const parsedStatus =
      typeof status === 'string'
        ? (status as SubscriptionStatus)
        : undefined;

    const parsedPlan =
      typeof plan === 'string'
        ? (plan as SubscriptionPlan)
        : undefined;

    const parsedProvider =
      typeof provider === 'string'
        ? (provider as PaymentProvider)
        : undefined;

    const parsedUserId =
      typeof userId === 'string' ? userId : undefined;

    /**
     * ‚öôÔ∏è Execu√ß√£o do service
     */
    const result = await ListAdminSubscriptionsService.execute({
      page: parsedPage,
      limit: parsedLimit,
      status: parsedStatus,
      plan: parsedPlan,
      provider: parsedProvider,
      userId: parsedUserId,
    });

    return res.status(200).json(result);
  }
}
</file>

<file path="src/controllers/admin/monetization.controller.ts">
import { Request, Response } from 'express';
import { AdminWalletService } from '../../services/admin/admin-wallet.service';
import { AdminLedgerService } from '../../services/admin/admin-ledger.service';
import { AdminSubscriptionService } from '../../services/admin/admin-subscription.service';
import { AdminWalletCreditService } from '../../services/admin/admin-wallet-credit.service';

export class AdminMonetizationController {
  static async wallet(req: Request, res: Response) {
    const { userId } = req.params;
    const wallet = await AdminWalletService.getWalletByUser(userId);
    return res.json(wallet);
  }

  static async ledger(req: Request, res: Response) {
    const { userId } = req.params;
    const ledger = await AdminLedgerService.listByUser(userId);
    return res.json(ledger);
  }

  static async subscriptions(req: Request, res: Response) {
    const { userId } = req.params;
    const subs = await AdminSubscriptionService.getByUser(userId);
    return res.json(subs);
  }

  static async credit(req: Request, res: Response) {
    const adminUserId = (req as any).user.id;
    const { userId } = req.params;
    const { amount, reason } = req.body;

    try {
      const result = await AdminWalletCreditService.credit(
        adminUserId,
        userId,
        Number(amount),
        reason
      );
      return res.json(result);
    } catch (e: any) {
      return res.status(400).json({ error: e.message });
    }
  }
}
</file>

<file path="src/controllers/bolao/bolao-ranking.controller.ts">
import { Request, Response } from 'express';
import { GetBolaoRankingService } from '../../services/bolao/get-bolao-ranking.service';

export class BolaoRankingController {
  static async handle(req: Request, res: Response) {
    const { rankingId } = req.params;

    if (!rankingId) {
      return res.status(400).json({
        error: 'rankingId is required',
      });
    }

    try {
      const ranking = await GetBolaoRankingService.execute(rankingId);

      return res.json({
        rankingId,
        total: ranking.length,
        ranking,
      });
    } catch (error: any) {
      return res.status(400).json({
        error: error.message ?? 'Failed to load bol√£o ranking',
      });
    }
  }
}
</file>

<file path="src/controllers/bolao/create-bolao-invite.controller.ts">
import { Request, Response } from 'express';
import { CreateBolaoInviteService } from '../../services/bolao/create-bolao-invite.service';

export class CreateBolaoInviteController {
  static async handle(req: Request, res: Response) {
    const { rankingId } = req.params;
    const userId = (req as any).user?.id;
    const { maxUses, expiresAt } = req.body ?? {};

    if (!rankingId) {
      return res.status(400).json({ error: 'rankingId is required' });
    }
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    try {
      const invite = await CreateBolaoInviteService.execute({
        rankingId,
        createdByUserId: userId,
        maxUses,
        expiresAt: expiresAt ? new Date(expiresAt) : undefined,
      });

      return res.status(201).json(invite);
    } catch (error: any) {
      return res.status(400).json({ error: error.message });
    }
  }
}
</file>

<file path="src/controllers/bolao/use-bolao-invite.controller.ts">
import { Request, Response } from 'express';
import { UseBolaoInviteService } from '../../services/bolao/use-bolao-invite.service';

export class UseBolaoInviteController {
  static async handle(req: Request, res: Response) {
    const { code } = req.params;
    const userId = (req as any).user?.id;

    if (!code) {
      return res.status(400).json({ error: 'invite code is required' });
    }
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    try {
      const result = await UseBolaoInviteService.execute({ code, userId });
      return res.json(result);
    } catch (error: any) {
      return res.status(400).json({ error: error.message });
    }
  }
}
</file>

<file path="src/controllers/internal/generate-ranking-snapshot.controller.ts">
import { Request, Response } from 'express';
import { SnapshotRankingService } from '../../services/ranking/snapshot-ranking.service';

export class GenerateRankingSnapshotController {
  static async handle(req: Request, res: Response) {
    const { roundId } = req.body;

    if (!roundId) {
      return res.status(400).json({
        error: 'roundId is required',
      });
    }

    try {
      await SnapshotRankingService.execute(roundId);

      return res.status(200).json({
        status: 'SNAPSHOT_GENERATED',
        roundId,
      });
    } catch (error: any) {
      return res.status(500).json({
        error: error.message ?? 'Snapshot generation failed',
      });
    }
  }
}
</file>

<file path="src/controllers/internal/mercado-pago-subscription.controller.ts">
import { Request, Response } from 'express';
import { ProcessMpSubscriptionCreatedService } from '../../services/subscription/process-mp-subscription-created.service';

export class MercadoPagoSubscriptionController {
  static async handle(req: Request, res: Response) {
    /**
     * Mercado Pago envia v√°rios tipos de eventos.
     * Aqui tratamos SOMENTE subscription.created
     */
    const event = req.body;

    if (event?.type !== 'subscription' || event?.action !== 'subscription.created') {
      return res.status(200).json({ ignored: true });
    }

    await ProcessMpSubscriptionCreatedService.execute(event);

    return res.status(200).json({ received: true });
  }
}
</file>

<file path="src/controllers/internal/score-round.job.controller.ts">
import { Request, Response } from 'express';
import { ScoreRoundService } from '../../services/score/score-round.service';

const INTERNAL_JOB_SECRET = process.env.INTERNAL_JOB_SECRET;

export class ScoreRoundJobController {
  async execute(req: Request, res: Response): Promise<Response> {
    try {
      const token = req.headers['x-internal-job-token'];

      if (!INTERNAL_JOB_SECRET || token !== INTERNAL_JOB_SECRET) {
        return res.status(401).json({
          error: 'Unauthorized internal job',
        });
      }

      const { roundId } = req.body;

      if (!roundId) {
        return res.status(400).json({
          error: 'roundId is required',
        });
      }

      const service = new ScoreRoundService();
      await service.execute(roundId);

      return res.status(200).json({
        status: 'ok',
        message: 'Round scored successfully',
      });
    } catch (error: any) {
      return res.status(500).json({
        error: error.message ?? 'Internal job error',
      });
    }
  }
}
</file>

<file path="src/controllers/me.controller.ts">
import { Response } from "express";
import { AuthRequest } from "../middleware/auth";  
import { UserProfileService } from "../services/user-profile.service";

export class MeController {
  async handle(req: AuthRequest, res: Response) {
    if (!req.user) {
      return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
    }

    // ‚úÖ Correto: vari√°vel local, valor vem de req.user.id
    const userId = req.user.id;

    const service = new UserProfileService();
    const profile = await service.execute(userId);

    return res.json(profile);
  }
}
</file>

<file path="src/controllers/ranking/semester-ranking.controller.ts">
import { Request, Response } from 'express';
import { GetSemesterRankingService } from '../../services/ranking/get-semester-ranking.service';

export class SemesterRankingController {
  static async handle(req: Request, res: Response) {
    const { period } = req.query;

    if (!period || typeof period !== 'string') {
      return res.status(400).json({
        error: 'Query param "period" is required (YYYY-S1 or YYYY-S2)',
      });
    }

    try {
      const ranking = await GetSemesterRankingService.execute(period);

      return res.json({
        period,
        total: ranking.length,
        ranking,
      });
    } catch (error: any) {
      return res.status(400).json({
        error: error.message ?? 'Failed to load semester ranking',
      });
    }
  }
}
</file>

<file path="src/controllers/ranking/weekly-ranking.controller.ts">
import { Request, Response } from 'express';
import { GetWeeklyRankingService } from '../../services/ranking/get-weekly-ranking.service';

export class WeeklyRankingController {
  static async handle(req: Request, res: Response) {
    const { period } = req.query;

    if (!period || typeof period !== 'string') {
      return res.status(400).json({
        error: 'Query param "period" is required (YYYY-WW)',
      });
    }

    try {
      const ranking = await GetWeeklyRankingService.execute(period);

      return res.json({
        period,
        total: ranking.length,
        ranking,
      });
    } catch (error: any) {
      return res.status(400).json({
        error: error.message ?? 'Failed to load weekly ranking',
      });
    }
  }
}
</file>

<file path="src/controllers/ticket.controller.ts">
import { Request, Response } from 'express';
import { CreateTicketService } from '../services/ticket/create-ticket.service';

export class TicketController {
  static async create(req: Request, res: Response) {
    const userId = (req as any).user?.id;
    const { roundId, prediction, useBenefit } = req.body;

    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    if (!roundId || !prediction) {
      return res.status(400).json({
        error: 'roundId and prediction are required',
      });
    }

    try {
      const ticket = await CreateTicketService.execute({
        userId,
        roundId,
        prediction,
        useBenefit,
      });

      return res.status(201).json(ticket);
    } catch (error: any) {
      return res.status(400).json({
        error: error.message ?? 'Failed to create ticket',
      });
    }
  }
}
</file>

<file path="src/controllers/user.controller.ts">
import { Request, Response } from "express";
import { UserService } from "../services/user.service";

export class UserController {
  private service = new UserService();

  async create(req: Request, res: Response) {
    try {
      const user = await this.service.createUser(req.body);
      return res.status(201).json(user);
    } catch (error: any) {
      return res.status(400).json({
        error: error.message ?? "Erro ao criar usu√°rio"
      });
    }
  }
}
</file>

<file path="src/domain/payment-packages.ts">

</file>

<file path="src/domain/permissions.ts">
import { UserRole } from '@prisma/client';

// Exportar o tipo do Prisma como Role (compatibilidade)
export type Role = UserRole;

// Permiss√µes do sistema
export type Permission =
  | 'USER_READ'
  | 'USER_WRITE'
  | 'ADMIN_PANEL'
  | 'AUDIT_READ';

// Mapeamento de roles para permiss√µes
export const RolePermissions: Record<UserRole, Permission[]> = {
  ADMIN: ['USER_READ', 'USER_WRITE', 'ADMIN_PANEL', 'AUDIT_READ'],
  PRO: ['USER_READ'],
  NORMAL: []
};
</file>

<file path="src/errors/AppError.ts">
export class AppError extends Error {
  public readonly statusCode: number;

  constructor(message: string, statusCode = 400) {
    super(message);
    this.statusCode = statusCode;
    Object.setPrototypeOf(this, AppError.prototype);
  }
}
</file>

<file path="src/middleware/auth.ts">
import { Request, Response, NextFunction } from 'express';
import { verifyToken, JWTPayload } from '../utils/jwt';

export interface AuthRequest extends Request {
  user?: JWTPayload;
}

export function authMiddleware(
  req: AuthRequest,
  res: Response,
  next: NextFunction
) {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    return res.status(401).json({ error: 'Token n√£o informado' });
  }

  const [, token] = authHeader.split(' ');
  if (!token) {
    return res.status(401).json({ error: 'Token malformado' });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    return next();
  } catch {
    return res.status(401).json({ error: 'Token inv√°lido ou expirado' });
  }
}
</file>

<file path="src/middleware/error-handler.ts">
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../errors/AppError';

export function errorHandler(
  err: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
) {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      error: err.message
    });
  }

  console.error('[UNHANDLED ERROR]', err);

  return res.status(500).json({
    error: 'Erro interno do servidor'
  });
}
</file>

<file path="src/middleware/internal-job-auth.middleware.ts">
import { Request, Response, NextFunction } from 'express';

export function internalJobAuth(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const token = req.headers['x-internal-job-token'];

  if (!token || token !== process.env.INTERNAL_JOB_TOKEN) {
    return res.status(401).json({
      error: 'Unauthorized internal job',
    });
  }

  return next();
}
</file>

<file path="src/middleware/require-admin.middleware.ts">
import { Request, Response, NextFunction } from 'express';

export function requireAdmin(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const user = (req as any).user;

  if (!user || user.role !== 'ADMIN') {
    return res.status(403).json({ error: 'Admin access required' });
  }

  next();
}
</file>

<file path="src/middleware/requirePermission.ts">
import { Response, NextFunction } from 'express';
import { AuthRequest } from './auth';
import { Permission, RolePermissions } from '../domain/permissions';
import { UserRole } from '@prisma/client';

export function requirePermission(permission: Permission) {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
    }

    // Cast expl√≠cito para UserRole do Prisma
    const userRole = req.user.role as UserRole;
    const allowed = RolePermissions[userRole] || [];

    if (!allowed.includes(permission)) {
      return res.status(403).json({ error: 'Permiss√£o negada' });
    }

    next();
  };
}
</file>

<file path="src/middleware/requireRole.ts">
import { Response, NextFunction } from 'express';
import { prisma } from '../lib/prisma';
import { AuthRequest } from './auth';

type Role = 'ADMIN' | 'PRO' | 'NORMAL';

export const requireRole = (allowedRoles: Role[]) => {
  return async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
      // üîí Type guard expl√≠cito
      if (!req.user) {
        return res.status(401).json({ error: 'Usu√°rio n√£o autenticado' });
      }

      const userId = req.user.id;

      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { role: true }
      });

      if (!user) {
        return res.status(401).json({ error: 'Usu√°rio inv√°lido' });
      }

      if (!allowedRoles.includes(user.role)) {
        return res.status(403).json({ error: 'Acesso negado' });
      }

      // ‚úÖ Agora o TS SABE que req.user existe
      req.user.role = user.role;

      return next();
    } catch (error) {
      console.error('[RBAC ERROR]', error);
      return res.status(500).json({ error: 'Erro interno de autoriza√ß√£o' });
    }
  };
};
</file>

<file path="src/repositories/round.repository.ts">
import { prisma } from '../lib/prisma';
import { RoundStatus } from '@prisma/client';

export class RoundRepository {

  async getLastRoundNumber(): Promise<number> {
    const last = await prisma.round.findFirst({
      orderBy: { number: 'desc' },
      select: { number: true }
    });

    return last?.number ?? 0;
  }

  async findOpenRound() {
    return prisma.round.findFirst({
      where: { status: RoundStatus.OPEN }
    });
  }

  async create(data: {
    number: number;
    openAt: Date;
    closeAt: Date;
  }) {
    return prisma.round.create({
      data: {
        number: data.number,
        openAt: data.openAt,
        closeAt: data.closeAt,
        status: RoundStatus.OPEN
      }
    });
  }

  async updateStatus(roundId: string, status: RoundStatus) {
    return prisma.round.update({
      where: { id: roundId },
      data: { status }
    });
  }

  async findById(roundId: string) {
    return prisma.round.findUnique({
      where: { id: roundId }
    });
  }
}
</file>

<file path="src/repositories/ticket.repository.ts">
import { prisma } from '../lib/prisma';
import { TicketStatus, Ticket } from '@prisma/client';

export class TicketRepository {
  async findByUserAndRound(userId: string, roundId: string) {
    return prisma.ticket.findUnique({
      where: {
        userId_roundId: {
          userId,
          roundId
        }
      }
    });
  }

  async findByRound(roundId: string): Promise<Ticket[]> {
    return prisma.ticket.findMany({
      where: { roundId }
    });
  }

  async create(data: {
    userId: string;
    roundId: string;
    prediction: string;
  }) {
    return prisma.ticket.create({
      data: {
        userId: data.userId,
        roundId: data.roundId,
        prediction: data.prediction,
        status: TicketStatus.PENDING
      }
    });
  }

  async updatePrediction(ticketId: string, prediction: string) {
    return prisma.ticket.update({
      where: { id: ticketId },
      data: {
        prediction,
        updatedAt: new Date()
      }
    });
  }

  async updateStatus(ticketId: string, status: TicketStatus) {
    return prisma.ticket.update({
      where: { id: ticketId },
      data: { status }
    });
  }

  async updateScore(ticketId: string, scoreRound: number): Promise<Ticket> {
    return prisma.ticket.update({
      where: { id: ticketId },
      data: {
        scoreRound,
        updatedAt: new Date()
      }
    });
  }
}
</file>

<file path="src/repositories/user-score-history.repository.ts">
import { prisma } from '../lib/prisma';

export class UserScoreHistoryRepository {
  async findLastByUser(userId: string) {
    return prisma.userScoreHistory.findFirst({
      where: { userId },
      orderBy: { createdAt: 'desc' }
    });
  }

  async create(data: {
    userId: string;
    roundId: string;
    scoreRound: number;
    scoreTotal: number;
  }) {
    return prisma.userScoreHistory.create({ data });
  }
}
</file>

<file path="src/repositories/user.repository.ts">
import { prisma } from "../lib/prisma";
import { Prisma } from "@prisma/client";

export class UserRepository {
  async findByEmail(email: string) {
    return prisma.user.findUnique({
      where: { email }
    });
  }

  async findByCpf(cpf: string) {
    return prisma.user.findUnique({
      where: { cpf }
    });
  }

  async findById(id: string) {
    return prisma.user.findUnique({
      where: { id }
    });
  }

  async create(data: Prisma.UserCreateInput) {
    return prisma.user.create({
      data
    });
  }
}
</file>

<file path="src/routes/admin-monetization.routes.ts">
import { Router } from 'express';
import { requireAdmin } from '../middleware/require-admin.middleware';
import { AdminMonetizationController } from '../controllers/admin/monetization.controller';

const router = Router();

router.use(requireAdmin);

router.get('/admin/monetization/wallet/:userId', AdminMonetizationController.wallet);
router.get('/admin/monetization/ledger/:userId', AdminMonetizationController.ledger);
router.get('/admin/monetization/subscriptions/:userId', AdminMonetizationController.subscriptions);
router.post('/admin/monetization/wallet/:userId/credit', AdminMonetizationController.credit);

export default router;
</file>

<file path="src/routes/admin-subscriptions.routes.ts">
import { Router } from 'express';
import { AdminSubscriptionsController } from '../controllers/admin/admin-subscriptions.controller';

const router = Router();

/**
 * Painel ADMIN ‚Äî Assinaturas
 *
 * Prefixo final:
 * /api/admin/subscriptions
 */
router.get('/admin/subscriptions', AdminSubscriptionsController.list);

export default router;
</file>

<file path="src/routes/auth.ts">
import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { generateToken } from '../utils/jwt'; // ‚úÖ CORRETO
//import { signToken } from '../utils/jwt'; // ‚Üê Usando o helper

const router = Router();
const prisma = new PrismaClient();

router.post('/login', async (req: Request, res: Response): Promise<Response> => {
  try {
    const { email, password } = req.body as {
      email?: string;
      password?: string;
    };

    if (!email || !password) {
      return res.status(400).json({ error: 'Email e senha obrigat√≥rios' });
    }

    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    const validPassword = await bcrypt.compare(password, user.password);
    
    if (!validPassword) {
      return res.status(401).json({ error: 'Credenciais inv√°lidas' });
    }

    // ‚úÖ Usava signToken do helper
    const token = generateToken({
      id: user.id,
      email: user.email,
      role: user.role
    });

    return res.json({ token });
  } catch (error) {
    console.error('[AUTH LOGIN ERROR]', error);
    return res.status(500).json({ error: 'Erro interno no login' });
  }
});

export default router;
</file>

<file path="src/routes/health.ts">
import { Router } from "express";
import { prisma } from "../lib/prisma";

const router = Router();

router.get("/health", async (_req, res) => {
  await prisma.$queryRaw`SELECT 1`;
  return res.json({ api: "ok", db: "ok" });
});

export default router;
</file>

<file path="src/routes/internal/subscription-jobs.routes.ts">
import { Router } from 'express';
import { SubscriptionJobsController } from '../../controllers/internal/subscription-jobs.controller';

const router = Router();

/**
 * EXECU√á√ÉO INTERNA / CRON
 * POST /internal/jobs/subscriptions/revalidate
 */
router.post(
  '/jobs/subscriptions/revalidate',
  SubscriptionJobsController.revalidate
);

export default router;
</file>

<file path="src/routes/me.ts">
import { Router } from 'express';
import { authMiddleware } from '../middleware/auth';
import { MeController } from '../controllers/me.controller';

const router = Router();
const meController = new MeController();

router.get('/me', authMiddleware, (req, res) => {
  return meController.handle(req, res);
});

export default router;
</file>

<file path="src/routes/payment-packages.routes.ts">

</file>

<file path="src/routes/user.routes.ts">
import { Router } from "express";
import { UserController } from "../controllers/user.controller";

const router = Router();
const controller = new UserController();

router.post("/users", (req, res) => controller.create(req, res));

export default router;
</file>

<file path="src/services/admin/admin-benefits-paid.service.ts">
import { WalletService } from '../wallet/wallet.service';
import { prisma } from '../../lib/prisma';

export class AdminPaidBenefitsService {
  static async creditPaid(
    adminUserId: string,
    userId: string,
    amount: number,
    type: 'DOUBLE' | 'SUPER_DOUBLE'
  ) {
    const cost = type === 'DOUBLE' ? 1 : 2;

    await WalletService.credit(
      userId,
      amount * cost,
      `ADMIN CREDIT ${type}`
    );

    await prisma.auditLog.create({
      data: {
        userId: adminUserId,
        action: 'ADMIN_CREDIT_PAID_BENEFIT',
        entity: 'Wallet',
        entityId: userId,
        metadata: { type, amount },
      },
    });

    return { userId, type, amount };
  }
}
</file>

<file path="src/services/admin/admin-benefits.service.ts">
import { prisma } from '../../lib/prisma';

type BenefitType = 'DOUBLE' | 'SUPER_DOUBLE';

export class AdminBenefitsService {
  static async creditFree(
    adminUserId: string,
    userId: string,
    roundId: string,
    type: BenefitType,
    amount: number
  ) {
    if (amount <= 0) throw new Error('Invalid amount');

    const field =
      type === 'DOUBLE' ? 'freeDoubles' : 'freeSuperDoubles';

    const benefit = await prisma.roundBenefit.upsert({
      where: { userId_roundId: { userId, roundId } },
      update: {
        [field]: { increment: amount },
      },
      create: {
        userId,
        roundId,
        freeDoubles: type === 'DOUBLE' ? amount : 0,
        freeSuperDoubles: type === 'SUPER_DOUBLE' ? amount : 0,
      },
    });

    await prisma.auditLog.create({
      data: {
        userId: adminUserId,
        action: 'ADMIN_CREDIT_FREE_BENEFIT',
        entity: 'RoundBenefit',
        entityId: benefit.id,
        metadata: { userId, roundId, type, amount },
      },
    });

    return benefit;
  }
}
</file>

<file path="src/services/admin/admin-billing-metrics.service.ts">
import { prisma } from '../../lib/prisma';
import {
  PaymentStatus,
  WalletTransactionType,
  SubscriptionStatus,
  SubscriptionPlan,
} from '@prisma/client';

/**
 * Service ‚Äî M√©tricas de Billing (ADMIN)
 *
 * REGRAS:
 * - SOMENTE LEITURA
 * - Nenhuma escrita em banco
 * - Nenhuma altera√ß√£o de estado
 * - Nenhuma regra de neg√≥cio
 * - M√©tricas agregadas para opera√ß√£o
 */
export class AdminBillingMetricsService {
  static async execute() {
    /**
     * ======================
     * PAGAMENTOS
     * ======================
     */
    const [
      totalPayments,
      approvedPayments,
      rejectedPayments,
      pendingPayments,
      revenue,
    ] = await prisma.$transaction([
      prisma.payment.count(),
      prisma.payment.count({
        where: { status: PaymentStatus.APPROVED },
      }),
      prisma.payment.count({
        where: { status: PaymentStatus.REJECTED },
      }),
      prisma.payment.count({
        where: { status: PaymentStatus.PENDING },
      }),
      prisma.payment.aggregate({
        where: { status: PaymentStatus.APPROVED },
        _sum: { amountCents: true },
      }),
    ]);

    /**
     * ======================
     * WALLET (COINS CREDITADAS)
     * ======================
     */
    const totalCoinsCredited = await prisma.walletLedger.aggregate({
      where: { type: WalletTransactionType.CREDIT },
      _sum: { amount: true },
    });

    /**
     * ======================
     * ASSINATURAS
     * ======================
     */
    const [
      activeSubscriptions,
      cancelledSubscriptions,
      expiredSubscriptions,
      monthlySubscriptions,
      annualSubscriptions,
    ] = await prisma.$transaction([
      prisma.subscription.count({
        where: { status: SubscriptionStatus.ACTIVE },
      }),
      prisma.subscription.count({
        where: { status: SubscriptionStatus.CANCELLED },
      }),
      prisma.subscription.count({
        where: { status: SubscriptionStatus.EXPIRED },
      }),
      prisma.subscription.count({
        where: {
          status: SubscriptionStatus.ACTIVE,
          plan: SubscriptionPlan.MONTHLY,
        },
      }),
      prisma.subscription.count({
        where: {
          status: SubscriptionStatus.ACTIVE,
          plan: SubscriptionPlan.ANNUAL,
        },
      }),
    ]);

    /**
     * ======================
     * MRR ESTIMADO
     * ======================
     *
     * Regra:
     * - MONTHLY = 1x
     * - ANNUAL = dividido por 12
     *
     * ‚ö†Ô∏è Valores monet√°rios reais podem variar
     * ‚ö†Ô∏è M√©trica √© ESTIMADA (operacional)
     */
    const monthlyMRR = monthlySubscriptions;
    const annualMRR = annualSubscriptions / 12;

    return {
      payments: {
        total: totalPayments,
        approved: approvedPayments,
        rejected: rejectedPayments,
        pending: pendingPayments,
        revenueCents: revenue._sum.amountCents ?? 0,
      },

      wallet: {
        totalCoinsCredited: totalCoinsCredited._sum.amount ?? 0,
      },

      subscriptions: {
        active: activeSubscriptions,
        cancelled: cancelledSubscriptions,
        expired: expiredSubscriptions,
        byPlan: {
          monthly: monthlySubscriptions,
          annual: annualSubscriptions,
        },
      },

      mrr: {
        monthlyEstimated: monthlyMRR,
        annualEstimated: annualMRR,
      },
    };
  }
}
</file>

<file path="src/services/admin/admin-ledger.service.ts">
import { prisma } from '../../lib/prisma';

export class AdminLedgerService {
  static async listByUser(userId: string) {
    return prisma.walletLedger.findMany({
      where: {
        wallet: { userId },
      },
      orderBy: { createdAt: 'desc' },
      select: {
        type: true,
        amount: true,
        description: true,
        createdAt: true,
      },
    });
  }
}
</file>

<file path="src/services/admin/admin-role.service.ts">
import { prisma } from '../../lib/prisma';

export class AdminRoleService {
  static async setRole(
    adminUserId: string,
    targetUserId: string,
    role: 'NORMAL' | 'PRO' | 'ADMIN'
  ) {
    await prisma.user.update({
      where: { id: targetUserId },
      data: { role },
    });

    await prisma.auditLog.create({
      data: {
        userId: adminUserId,
        action: 'ADMIN_SET_ROLE',
        entity: 'User',
        entityId: targetUserId,
        metadata: { role },
      },
    });

    return { userId: targetUserId, role };
  }
}
</file>

<file path="src/services/admin/admin-subscription.service.ts">
import { prisma } from '../../lib/prisma';

export class AdminSubscriptionService {
  static async getByUser(userId: string) {
    return prisma.subscription.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      select: {
        plan: true,
        status: true,
        startAt: true,
        endAt: true,
      },
    });
  }
}
</file>

<file path="src/services/admin/admin-wallet-credit.service.ts">
import { prisma } from '../../lib/prisma';

export class AdminWalletCreditService {
  static async credit(
    adminUserId: string,
    userId: string,
    amount: number,
    reason: string
  ) {
    if (amount <= 0) {
      throw new Error('Amount must be greater than zero');
    }

    return prisma.$transaction(async tx => {
      const wallet = await tx.wallet.upsert({
        where: { userId },
        update: {},
        create: { userId },
      });

      await tx.wallet.update({
        where: { id: wallet.id },
        data: { balance: { increment: amount } },
      });

      await tx.walletLedger.create({
        data: {
          walletId: wallet.id,
          type: 'CREDIT',
          amount,
          description: `ADMIN CREDIT: ${reason}`,
        },
      });

      await tx.auditLog.create({
        data: {
          userId: adminUserId,
          action: 'ADMIN_WALLET_CREDIT',
          entity: 'Wallet',
          entityId: wallet.id,
          metadata: { targetUserId: userId, amount, reason },
        },
      });

      return {
        userId,
        credited: amount,
        balanceAfter: wallet.balance + amount,
      };
    });
  }
}
</file>

<file path="src/services/admin/admin-wallet.service.ts">
import { prisma } from '../../lib/prisma';

export class AdminWalletService {
  static async getWalletByUser(userId: string) {
    return prisma.wallet.findUnique({
      where: { userId },
      select: {
        userId: true,
        balance: true,
        updatedAt: true,
      },
    });
  }
}
</file>

<file path="src/services/admin/cancel-subscription.service.ts">

</file>

<file path="src/services/admin/get-admin-subscription.service.ts">
import { prisma } from '../../lib/prisma';

export class GetAdminSubscriptionService {
  static async execute(subscriptionId: string) {
    /**
     * 1Ô∏è‚É£ Buscar assinatura
     */
    const subscription = await prisma.subscription.findUnique({
      where: { id: subscriptionId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            role: true,
            createdAt: true,
          },
        },
      },
    });

    if (!subscription) {
      throw new Error('Subscription not found');
    }

    /**
     * 2Ô∏è‚É£ Buscar eventos de webhook (somente se houver externalSubscriptionId)
     */
    const webhookEvents = subscription.externalSubscriptionId
      ? await prisma.paymentWebhookEvent.findMany({
          where: {
            provider: 'MERCADO_PAGO',
            payload: {
              path: ['id'],
              equals: subscription.externalSubscriptionId,
            },
          },
          orderBy: {
            receivedAt: 'desc',
          },
          take: 10,
        })
      : [];

    /**
     * 3Ô∏è‚É£ Retorno estruturado
     */
    return {
      subscription: {
        id: subscription.id,
        plan: subscription.plan,
        status: subscription.status,
        provider: subscription.provider,
        externalSubscriptionId: subscription.externalSubscriptionId,
        externalCustomerId: subscription.externalCustomerId,
        startAt: subscription.startAt,
        endAt: subscription.endAt,
        createdAt: subscription.createdAt,
        updatedAt: subscription.updatedAt,
      },
      user: subscription.user,
      webhookEvents: webhookEvents.map((event) => ({
        id: event.id,
        externalEventId: event.externalEventId,
        receivedAt: event.receivedAt,
        payload: event.payload,
      })),
    };
  }
}
</file>

<file path="src/services/admin/list-admin-subscriptions.service.ts">
import { prisma } from '../../lib/prisma';
import {
  Prisma,
  SubscriptionStatus,
  SubscriptionPlan,
  PaymentProvider,
} from '@prisma/client';

/**
 * Lista assinaturas para o painel ADMIN
 *
 * REGRAS:
 * - Somente leitura
 * - Pagina√ß√£o obrigat√≥ria
 * - Filtros opcionais
 * - Sem l√≥gica de neg√≥cio
 * - Sem chamadas externas
 */
export interface ListAdminSubscriptionsParams {
  page?: number;
  limit?: number;
  status?: SubscriptionStatus;
  plan?: SubscriptionPlan;
  provider?: PaymentProvider;
  userId?: string;
}

export class ListAdminSubscriptionsService {
  static async execute(params: ListAdminSubscriptionsParams) {
    /**
     * 1Ô∏è‚É£ Pagina√ß√£o defensiva
     */
    const page = params.page && params.page > 0 ? params.page : 1;
    const limit =
      params.limit && params.limit > 0 && params.limit <= 100
        ? params.limit
        : 20;

    const skip = (page - 1) * limit;

    /**
     * 2Ô∏è‚É£ Filtros type-safe
     */
    const where: Prisma.SubscriptionWhereInput = {
      ...(params.status && { status: params.status }),
      ...(params.plan && { plan: params.plan }),
      ...(params.provider && { provider: params.provider }),
      ...(params.userId && { userId: params.userId }),
    };

    /**
     * 3Ô∏è‚É£ Query transacional (count + list)
     */
    const [total, subscriptions] = await prisma.$transaction([
      prisma.subscription.count({ where }),

      prisma.subscription.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          status: true,
          plan: true,
          provider: true,
          startAt: true,
          endAt: true,
          externalSubscriptionId: true,
          externalCustomerId: true,
          createdAt: true,
          updatedAt: true,

          user: {
            select: {
              id: true,
              name: true,
              email: true,
              role: true,
              createdAt: true,
            },
          },
        },
      }),
    ]);

    /**
     * 4Ô∏è‚É£ Retorno padronizado para UI ADMIN
     */
    return {
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
      data: subscriptions,
    };
  }
}
</file>

<file path="src/services/admin/list-subscriptions.service.ts">
import { prisma } from '../../lib/prisma';
import {
  Prisma,
  SubscriptionStatus,
  SubscriptionPlan,
  PaymentProvider,
} from '@prisma/client';

/**
 * Lista assinaturas para o painel ADMIN
 *
 * REGRAS:
 * - Somente leitura
 * - Pagina√ß√£o obrigat√≥ria
 * - Filtros opcionais
 * - Sem l√≥gica de neg√≥cio
 * - Sem chamadas externas
 */
export interface ListAdminSubscriptionsParams {
  page?: number;
  limit?: number;
  status?: SubscriptionStatus;
  plan?: SubscriptionPlan;
  provider?: PaymentProvider;
  userId?: string;
}

export class ListAdminSubscriptionsService {
  static async execute(params: ListAdminSubscriptionsParams) {
    /**
     * 1Ô∏è‚É£ Pagina√ß√£o defensiva
     */
    const page = params.page && params.page > 0 ? params.page : 1;
    const limit =
      params.limit && params.limit > 0 && params.limit <= 100
        ? params.limit
        : 20;

    const skip = (page - 1) * limit;

    /**
     * 2Ô∏è‚É£ Filtros type-safe
     */
    const where: Prisma.SubscriptionWhereInput = {
      ...(params.status && { status: params.status }),
      ...(params.plan && { plan: params.plan }),
      ...(params.provider && { provider: params.provider }),
      ...(params.userId && { userId: params.userId }),
    };

    /**
     * 3Ô∏è‚É£ Query transacional (count + list)
     */
    const [total, subscriptions] = await prisma.$transaction([
      prisma.subscription.count({ where }),

      prisma.subscription.findMany({
        where,
        skip,
        take: limit,
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          status: true,
          plan: true,
          provider: true,
          startAt: true,
          endAt: true,
          externalSubscriptionId: true,
          externalCustomerId: true,
          createdAt: true,
          updatedAt: true,

          user: {
            select: {
              id: true,
              name: true,
              email: true,
              role: true,
              createdAt: true,
            },
          },
        },
      }),
    ]);

    /**
     * 4Ô∏è‚É£ Retorno padronizado para UI ADMIN
     */
    return {
      meta: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
      data: subscriptions,
    };
  }
}
</file>

<file path="src/services/alerts/detect-job-anomalies.service.ts">
import { prisma } from '../../lib/prisma';

export class DetectJobAnomaliesService {
  /**
   * Detecta poss√≠veis falhas de execu√ß√£o de jobs internos
   *
   * Estrat√©gia v1.9 (stateless):
   * - Usa sinais indiretos
   * - Ex: aus√™ncia de eventos recentes esperados
   * - N√£o persiste estado
   */
  static async execute(): Promise<void> {
    const timestamp = new Date().toISOString();

    /**
     * Exemplo: job de revalida√ß√£o deveria gerar logs/eventos indiretos
     * Usamos paymentWebhookEvent como proxy de atividade do sistema
     */
    const lastEvent = await prisma.paymentWebhookEvent.findFirst({
      orderBy: {
        receivedAt: 'desc',
      },
    });

    if (!lastEvent) {
      console.error({
        level: 'CRITICAL',
        service: 'DetectJobAnomaliesService',
        action: 'job.no_activity_detected',
        message:
          'Nenhum evento recente encontrado ‚Äî poss√≠vel falha de jobs internos',
        timestamp,
      });

      return;
    }

    const diffMinutes =
      (Date.now() - lastEvent.receivedAt.getTime()) / 60000;

    if (diffMinutes > 60) {
      console.warn({
        level: 'WARN',
        service: 'DetectJobAnomaliesService',
        action: 'job.possible_stall',
        message: `Sistema sem atividade relevante h√° ${Math.floor(
          diffMinutes
        )} minutos`,
        lastEventAt: lastEvent.receivedAt,
        timestamp,
      });
    }
  }
}
</file>

<file path="src/services/alerts/detect-payment-anomalies.service.ts">
import { prisma } from '../../lib/prisma';

export class DetectPaymentAlertsService {
  static async execute(): Promise<void> {
    const timestamp = new Date().toISOString();

    const anomalousPayments = await prisma.payment.findMany({
      where: {
        status: 'APPROVED',
        isCredited: false,
      },
    });

    for (const payment of anomalousPayments) {
      console.error({
        level: 'CRITICAL',
        service: 'DetectPaymentAlertsService',
        action: 'payment.approved_not_credited',
        paymentId: payment.id,
        userId: payment.userId,
        message: 'Pagamento aprovado sem cr√©dito na wallet',
        timestamp,
      });
    }
  }
}
</file>

<file path="src/services/alerts/detect-subscription-anomalies.service.ts">
import { prisma } from '../../lib/prisma';

export class DetectSubscriptionAlertsService {
  static async execute(): Promise<void> {
    const timestamp = new Date().toISOString();

    const inconsistencies = await prisma.subscription.findMany({
      where: {
        OR: [
          {
            status: 'ACTIVE',
            user: { role: 'NORMAL' },
          },
          {
            status: { in: ['CANCELLED', 'EXPIRED'] },
            user: { role: 'PRO' },
          },
        ],
      },
      include: {
        user: true,
      },
    });

    for (const sub of inconsistencies) {
      console.error({
        level: 'CRITICAL',
        service: 'DetectSubscriptionAlertsService',
        action: 'subscription.role_mismatch',
        subscriptionId: sub.id,
        userId: sub.userId,
        message: `Inconsist√™ncia assinatura (${sub.status}) x papel (${sub.user.role})`,
        timestamp,
      });
    }
  }
}
</file>

<file path="src/services/alerts/detect-webhook-anomalies.service.ts">
import { prisma } from '../../lib/prisma';

export class DetectWebhookAlertsService {
  static async execute(): Promise<void> {
    const timestamp = new Date().toISOString();

    const recentEvents = await prisma.paymentWebhookEvent.count({
      where: {
        receivedAt: {
          gte: new Date(Date.now() - 5 * 60 * 1000), // √∫ltimos 5 minutos
        },
      },
    });

    if (recentEvents > 100) {
      console.warn({
        level: 'WARN',
        service: 'DetectWebhookAlertsService',
        action: 'webhook.high_volume',
        message: `Volume elevado de webhooks nos √∫ltimos 5 minutos (${recentEvents})`,
        timestamp,
      });
    }
  }
}
</file>

<file path="src/services/benefits/consume-benefits.service.ts">
import { prisma } from '../../lib/prisma';
import { WalletService } from '../wallet/wallet.service';

type ConsumeInput = {
  userId: string;
  roundId: string;
  type: 'DOUBLE' | 'SUPER_DOUBLE';
};

export class ConsumeBenefitsService {
  static async execute({ userId, roundId, type }: ConsumeInput) {
    return prisma.$transaction(async tx => {
      const benefit = await tx.roundBenefit.findUnique({
        where: { userId_roundId: { userId, roundId } },
      });

      if (!benefit) {
        throw new Error('Round benefits not found');
      }

      // 1Ô∏è‚É£ Consumir FREE primeiro
      if (type === 'DOUBLE' && benefit.freeDoubles > 0) {
        await tx.roundBenefit.update({
          where: { id: benefit.id },
          data: { freeDoubles: { decrement: 1 } },
        });
        return { consumed: 'FREE_DOUBLE' };
      }

      if (type === 'SUPER_DOUBLE' && benefit.freeSuperDoubles > 0) {
        await tx.roundBenefit.update({
          where: { id: benefit.id },
          data: { freeSuperDoubles: { decrement: 1 } },
        });
        return { consumed: 'FREE_SUPER_DOUBLE' };
      }

      // 2Ô∏è‚É£ Consumir COMPRADO (coins)
      const cost = type === 'DOUBLE' ? 1 : 2; // regra de pre√ßo t√©cnico (ajust√°vel)

      await WalletService.debit(
        userId,
        cost,
        `Consume ${type} on round ${roundId}`
      );

      return { consumed: 'PAID', cost };
    });
  }
}
</file>

<file path="src/services/benefits/round-benefit.service.ts">
import { prisma } from '../../lib/prisma';
import { SubscriptionService } from '../subscription/subscription.service';

export class RoundBenefitService {
  static async grantForRound(roundId: string) {
    const users = await prisma.user.findMany({
      select: { id: true, role: true },
    });

    for (const user of users) {
      let freeDoubles = 0;
      let freeSuperDoubles = 0;

      if (user.role === 'NORMAL') {
        freeDoubles = 2;
      }

      if (user.role === 'PRO') {
        freeDoubles = 4;
        freeSuperDoubles = 1;
      }

      await prisma.roundBenefit.create({
        data: {
          userId: user.id,
          roundId,
          freeDoubles,
          freeSuperDoubles,
        },
      });
    }
  }

  static async get(userId: string, roundId: string) {
    return prisma.roundBenefit.findUnique({
      where: { userId_roundId: { userId, roundId } },
    });
  }
}
</file>

<file path="src/services/bolao/create-bolao-invite.service.ts">
import { prisma } from '../../lib/prisma';
import { randomUUID } from 'crypto';

type CreateInviteInput = {
  rankingId: string;
  createdByUserId: string;
  maxUses?: number;
  expiresAt?: Date;
};

export class CreateBolaoInviteService {
  static async execute({
    rankingId,
    createdByUserId,
    maxUses,
    expiresAt,
  }: CreateInviteInput) {
    // validar ranking (bol√£o)
    const ranking = await prisma.ranking.findUnique({
      where: { id: rankingId },
      select: { id: true, type: true, createdByUserId: true },
    });

    if (!ranking) throw new Error('Bol√£o not found');
    if (ranking.type !== 'BOLAO') throw new Error('Ranking is not a bol√£o');

    // apenas o criador pode gerar convite (regra inicial)
    if (ranking.createdByUserId !== createdByUserId) {
      throw new Error('Only bol√£o creator can generate invites');
    }

    const code = randomUUID();

    const invite = await prisma.bolaoInvite.create({
      data: {
        rankingId,
        code,
        maxUses,
        expiresAt,
        createdByUserId,
      },
    });

    return {
      id: invite.id,
      code: invite.code,
      maxUses: invite.maxUses,
      expiresAt: invite.expiresAt,
      isActive: invite.isActive,
      createdAt: invite.createdAt,
    };
  }
}
</file>

<file path="src/services/bolao/get-bolao-ranking.service.ts">
import { prisma } from '../../lib/prisma';

type BolaoRankingItem = {
  userId: string;
  scoreTotal: number;
  scoreRound: number;
};

export class GetBolaoRankingService {
  static async execute(rankingId: string) {
    /**
     * 1Ô∏è‚É£ Buscar ranking (bol√£o)
     */
    const ranking = await prisma.ranking.findUnique({
      where: { id: rankingId },
      select: {
        id: true,
        type: true,
        status: true,
        startDate: true,
        endDate: true,
      },
    });

    if (!ranking) {
      throw new Error('Bol√£o not found');
    }

    if (ranking.type !== 'BOLAO') {
      throw new Error('Ranking is not a bol√£o');
    }

    if (ranking.status === 'DRAFT') {
      throw new Error('Bol√£o is not active yet');
    }

    if (!ranking.startDate || !ranking.endDate) {
      throw new Error('Bol√£o dates are not defined');
    }

    /**
     * 2Ô∏è‚É£ Buscar participantes do bol√£o
     */
    const participants = await prisma.rankingParticipant.findMany({
      where: { rankingId },
      select: { userId: true },
    });

    if (participants.length === 0) {
      return [];
    }

    const participantIds = participants.map(p => p.userId);

    /**
     * 3Ô∏è‚É£ Buscar snapshots v√°lidos no per√≠odo do bol√£o
     */
    const snapshots = await prisma.rankingSnapshot.findMany({
      where: {
        userId: { in: participantIds },
        round: {
          closeAt: {
            gte: ranking.startDate,
            lte: ranking.endDate,
          },
        },
      },
      select: {
        userId: true,
        scoreTotal: true,
        scoreRound: true,
        createdAt: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (snapshots.length === 0) {
      return [];
    }

    /**
     * 4Ô∏è‚É£ Consolidar √∫ltimo snapshot por usu√°rio
     */
    const latestByUser = new Map<string, BolaoRankingItem>();

    for (const snap of snapshots) {
      if (!latestByUser.has(snap.userId)) {
        latestByUser.set(snap.userId, {
          userId: snap.userId,
          scoreTotal: snap.scoreTotal,
          scoreRound: snap.scoreRound,
        });
      }
    }

    /**
     * 5Ô∏è‚É£ Ordenar ranking (read-only)
     */
    const ordered = Array.from(latestByUser.values()).sort((a, b) => {
      if (b.scoreTotal !== a.scoreTotal) {
        return b.scoreTotal - a.scoreTotal;
      }

      if (b.scoreRound !== a.scoreRound) {
        return b.scoreRound - a.scoreRound;
      }

      return a.userId.localeCompare(b.userId);
    });

    /**
     * 6Ô∏è‚É£ Gerar posi√ß√µes (empate real)
     */
    let position = 1;
    let lastScoreTotal: number | null = null;
    let lastScoreRound: number | null = null;
    let index = 0;

    return ordered.map(item => {
      index++;

      if (
        lastScoreTotal !== null &&
        (item.scoreTotal !== lastScoreTotal ||
          item.scoreRound !== lastScoreRound)
      ) {
        position = index;
      }

      lastScoreTotal = item.scoreTotal;
      lastScoreRound = item.scoreRound;

      return {
        ...item,
        position,
      };
    });
  }
}
</file>

<file path="src/services/bolao/join-bolao.controller.ts">
import { Request, Response } from 'express';
import { JoinBolaoService } from '../../services/bolao/join-bolao.service';

export class JoinBolaoController {
  static async handle(req: Request, res: Response) {
    const { rankingId } = req.params;
    const userId = (req as any).user?.id; // padr√£o j√° usado no projeto

    if (!rankingId) {
      return res.status(400).json({
        error: 'rankingId is required',
      });
    }

    if (!userId) {
      return res.status(401).json({
        error: 'User not authenticated',
      });
    }

    try {
      const result = await JoinBolaoService.execute({
        rankingId,
        userId,
      });

      return res.status(200).json(result);
    } catch (error: any) {
      return res.status(400).json({
        error: error.message ?? 'Failed to join bol√£o',
      });
    }
  }
}
</file>

<file path="src/services/bolao/join-bolao.service.ts">
import { prisma } from '../../lib/prisma';

type JoinBolaoInput = {
  rankingId: string;
  userId: string;
};

export class JoinBolaoService {
  static async execute({ rankingId, userId }: JoinBolaoInput) {
    return prisma.$transaction(async tx => {
      /**
       * 1Ô∏è‚É£ Buscar bol√£o com lock l√≥gico
       */
      const bolao = await tx.ranking.findUnique({
        where: { id: rankingId },
        select: {
          id: true,
          type: true,
          status: true,
          maxParticipants: true,
          currentParticipants: true,
          durationDays: true,
        },
      });

      if (!bolao) {
        throw new Error('Bol√£o not found');
      }

      if (bolao.type !== 'BOLAO') {
        throw new Error('Ranking is not a bol√£o');
      }

      if (bolao.status !== 'DRAFT') {
        throw new Error('Bol√£o is not open for new participants');
      }

      if (
        bolao.maxParticipants !== null &&
        bolao.currentParticipants >= bolao.maxParticipants
      ) {
        throw new Error('Bol√£o is already full');
      }

      /**
       * 2Ô∏è‚É£ Verificar se usu√°rio j√° √© participante
       */
      const alreadyParticipant = await tx.rankingParticipant.findUnique({
        where: {
          rankingId_userId: {
            rankingId,
            userId,
          },
        },
      });

      if (alreadyParticipant) {
        throw new Error('User already joined this bol√£o');
      }

      /**
       * 3Ô∏è‚É£ Inserir participante
       */
      await tx.rankingParticipant.create({
        data: {
          rankingId,
          userId,
          score: 0,
          scoreInitial: 0,
        },
      });

      /**
       * 4Ô∏è‚É£ Incrementar contador
       */
      const updatedParticipants = bolao.currentParticipants + 1;

      /**
       * 5Ô∏è‚É£ Ativa√ß√£o autom√°tica se atingir o limite
       */
      if (
        bolao.maxParticipants !== null &&
        updatedParticipants === bolao.maxParticipants
      ) {
        const startDate = new Date();
        const endDate = new Date(
          startDate.getTime() + (bolao.durationDays ?? 0) * 24 * 60 * 60 * 1000
        );

        await tx.ranking.update({
          where: { id: rankingId },
          data: {
            currentParticipants: updatedParticipants,
            status: 'ACTIVE',
            startDate,
            endDate,
          },
        });

        return {
          status: 'ACTIVATED',
          rankingId,
          currentParticipants: updatedParticipants,
          startDate,
          endDate,
        };
      }

      /**
       * 6Ô∏è‚É£ Apenas atualizar contador
       */
      await tx.ranking.update({
        where: { id: rankingId },
        data: {
          currentParticipants: updatedParticipants,
        },
      });

      return {
        status: 'JOINED',
        rankingId,
        currentParticipants: updatedParticipants,
      };
    });
  }
}
</file>

<file path="src/services/bolao/use-bolao-invite.service.ts">
import { prisma } from '../../lib/prisma';
import { JoinBolaoService } from './join-bolao.service';

type UseInviteInput = {
  code: string;
  userId: string;
};

export class UseBolaoInviteService {
  static async execute({ code, userId }: UseInviteInput) {
    return prisma.$transaction(async tx => {
      const invite = await tx.bolaoInvite.findUnique({
        where: { code },
        select: {
          id: true,
          rankingId: true,
          maxUses: true,
          usedCount: true,
          expiresAt: true,
          isActive: true,
        },
      });

      if (!invite) throw new Error('Invite not found');
      if (!invite.isActive) throw new Error('Invite is not active');
      if (invite.expiresAt && invite.expiresAt < new Date()) {
        throw new Error('Invite has expired');
      }
      if (invite.maxUses !== null && invite.usedCount >= invite.maxUses) {
        throw new Error('Invite usage limit reached');
      }

      // delega entrada ao fluxo oficial
      const joinResult = await JoinBolaoService.execute({
        rankingId: invite.rankingId,
        userId,
      });

      // incrementa uso do convite
      await tx.bolaoInvite.update({
        where: { id: invite.id },
        data: {
          usedCount: invite.usedCount + 1,
        },
      });

      return {
        ...joinResult,
        inviteCode: code,
      };
    });
  }
}
</file>

<file path="src/services/ranking/calculate-ranking.service.ts">
import { prisma } from '../../lib/prisma';

interface CalculateRankingInput {
  rankingStartDate: Date;
  rankingEndDate: Date;
}

interface RankingResult {
  userId: string;
  scoreInitial: number;
  scoreFinal: number;
  rankingScore: number;
  lastScoreRound: number;
  lastScoreDate: Date;
}

export class CalculateRankingService {

  async execute(
    input: CalculateRankingInput
  ): Promise<RankingResult[]> {

    const { rankingStartDate, rankingEndDate } = input;

    // Busca todos os usu√°rios que possuem hist√≥rico
    const users = await prisma.user.findMany({
      where: {
        scoreHistory: {
          some: {}
        }
      },
      select: {
        id: true
      }
    });

    const results: RankingResult[] = [];

    for (const user of users) {

      // scoreInitial = √∫ltimo score ANTERIOR √† data inicial
      const scoreInitialRecord = await prisma.userScoreHistory.findFirst({
        where: {
          userId: user.id,
          createdAt: {
            lt: rankingStartDate
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      const scoreInitial = scoreInitialRecord?.scoreTotal ?? 0;

      // scoreFinal = √∫ltimo score <= data final
      const scoreFinalRecord = await prisma.userScoreHistory.findFirst({
        where: {
          userId: user.id,
          createdAt: {
            lte: rankingEndDate
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      // Se o usu√°rio n√£o pontuou dentro do per√≠odo, ignora
      if (!scoreFinalRecord) {
        continue;
      }

      const scoreFinal = scoreFinalRecord.scoreTotal;
      const rankingScore = scoreFinal - scoreInitial;

      results.push({
        userId: user.id,
        scoreInitial,
        scoreFinal,
        rankingScore,
        lastScoreRound: scoreFinalRecord.scoreRound,
        lastScoreDate: scoreFinalRecord.createdAt
      });
    }

    return results;
  }
}
</file>

<file path="src/services/ranking/get-monthly-ranking.service.ts">
import { prisma } from '../../lib/prisma';

type MonthlyRankingItem = {
  userId: string;
  scoreTotal: number;
  scoreRound: number;
};

export class GetMonthlyRankingService {
  static async execute(periodRef: string) {
    /**
     * 1Ô∏è‚É£ Validar per√≠odo (YYYY-MM)
     */
    if (!/^\d{4}-\d{2}$/.test(periodRef)) {
      throw new Error('Invalid period format. Expected YYYY-MM');
    }

    /**
     * 2Ô∏è‚É£ Buscar snapshots do per√≠odo
     * Apenas GLOBAL, apenas leitura
     */
    const snapshots = await prisma.rankingSnapshot.findMany({
      where: {
        snapshotType: 'GLOBAL',
        periodRef,
      },
      select: {
        userId: true,
        scoreTotal: true,
        scoreRound: true,
        createdAt: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (snapshots.length === 0) {
      return [];
    }

    /**
     * 3Ô∏è‚É£ Consolidar √∫ltimo snapshot do per√≠odo por usu√°rio
     */
    const latestByUser = new Map<string, MonthlyRankingItem>();

    for (const snap of snapshots) {
      if (!latestByUser.has(snap.userId)) {
        latestByUser.set(snap.userId, {
          userId: snap.userId,
          scoreTotal: snap.scoreTotal,
          scoreRound: snap.scoreRound,
        });
      }
    }

    /**
     * 4Ô∏è‚É£ Ordena√ß√£o final (read-only)
     */
    const ranking = Array.from(latestByUser.values()).sort((a, b) => {
      if (b.scoreTotal !== a.scoreTotal) {
        return b.scoreTotal - a.scoreTotal;
      }

      if (b.scoreRound !== a.scoreRound) {
        return b.scoreRound - a.scoreRound;
      }

      return a.userId.localeCompare(b.userId);
    });

    /**
     * 5Ô∏è‚É£ Gerar posi√ß√µes (empate real)
     */
    let position = 1;
    let lastScoreTotal: number | null = null;
    let lastScoreRound: number | null = null;
    let index = 0;

    return ranking.map(item => {
      index++;

      if (
        lastScoreTotal !== null &&
        (item.scoreTotal !== lastScoreTotal ||
          item.scoreRound !== lastScoreRound)
      ) {
        position = index;
      }

      lastScoreTotal = item.scoreTotal;
      lastScoreRound = item.scoreRound;

      return {
        ...item,
        position,
      };
    });
  }
}
</file>

<file path="src/services/ranking/get-semester-ranking.service.ts">
import { prisma } from '../../lib/prisma';

type SemesterRankingItem = {
  userId: string;
  scoreTotal: number;
  scoreRound: number;
};

export class GetSemesterRankingService {
  static async execute(periodRef: string) {
    /**
     * 1Ô∏è‚É£ Validar per√≠odo (YYYY-S1 ou YYYY-S2)
     */
    if (!/^\d{4}-S[12]$/.test(periodRef)) {
      throw new Error('Invalid period format. Expected YYYY-S1 or YYYY-S2');
    }

    /**
     * 2Ô∏è‚É£ Buscar snapshots do semestre
     */
    const snapshots = await prisma.rankingSnapshot.findMany({
      where: {
        snapshotType: 'GLOBAL',
        periodRef,
      },
      select: {
        userId: true,
        scoreTotal: true,
        scoreRound: true,
        createdAt: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (snapshots.length === 0) {
      return [];
    }

    /**
     * 3Ô∏è‚É£ Consolidar √∫ltimo snapshot do semestre por usu√°rio
     */
    const latestByUser = new Map<string, SemesterRankingItem>();

    for (const snap of snapshots) {
      if (!latestByUser.has(snap.userId)) {
        latestByUser.set(snap.userId, {
          userId: snap.userId,
          scoreTotal: snap.scoreTotal,
          scoreRound: snap.scoreRound,
        });
      }
    }

    /**
     * 4Ô∏è‚É£ Ordena√ß√£o final (read-only)
     */
    const ranking = Array.from(latestByUser.values()).sort((a, b) => {
      if (b.scoreTotal !== a.scoreTotal) {
        return b.scoreTotal - a.scoreTotal;
      }

      if (b.scoreRound !== a.scoreRound) {
        return b.scoreRound - a.scoreRound;
      }

      return a.userId.localeCompare(b.userId);
    });

    /**
     * 5Ô∏è‚É£ Calcular posi√ß√µes (empate real)
     */
    let position = 1;
    let lastScoreTotal: number | null = null;
    let lastScoreRound: number | null = null;
    let index = 0;

    return ranking.map(item => {
      index++;

      if (
        lastScoreTotal !== null &&
        (item.scoreTotal !== lastScoreTotal ||
          item.scoreRound !== lastScoreRound)
      ) {
        position = index;
      }

      lastScoreTotal = item.scoreTotal;
      lastScoreRound = item.scoreRound;

      return {
        ...item,
        position,
      };
    });
  }
}
</file>

<file path="src/services/ranking/get-weekly-ranking.service.ts">
import { prisma } from '../../lib/prisma';

type WeeklyRankingItem = {
  userId: string;
  scoreTotal: number;
  scoreRound: number;
};

export class GetWeeklyRankingService {
  static async execute(periodRef: string) {
    /**
     * 1Ô∏è‚É£ Validar per√≠odo (YYYY-WW)
     */
    if (!/^\d{4}-\d{2}$/.test(periodRef)) {
      throw new Error('Invalid period format. Expected YYYY-WW');
    }

    /**
     * 2Ô∏è‚É£ Buscar snapshots da semana (read-only)
     */
    const snapshots = await prisma.rankingSnapshot.findMany({
      where: {
        snapshotType: 'WEEKLY',
        periodRef,
      },
      select: {
        userId: true,
        scoreTotal: true,
        scoreRound: true,
        createdAt: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (snapshots.length === 0) {
      return [];
    }

    /**
     * 3Ô∏è‚É£ Consolidar √∫ltimo snapshot da semana por usu√°rio
     */
    const latestByUser = new Map<string, WeeklyRankingItem>();

    for (const snap of snapshots) {
      if (!latestByUser.has(snap.userId)) {
        latestByUser.set(snap.userId, {
          userId: snap.userId,
          scoreTotal: snap.scoreTotal,
          scoreRound: snap.scoreRound,
        });
      }
    }

    /**
     * 4Ô∏è‚É£ Ordena√ß√£o final (read-only)
     */
    const ranking = Array.from(latestByUser.values()).sort((a, b) => {
      if (b.scoreTotal !== a.scoreTotal) {
        return b.scoreTotal - a.scoreTotal;
      }

      if (b.scoreRound !== a.scoreRound) {
        return b.scoreRound - a.scoreRound;
      }

      return a.userId.localeCompare(b.userId);
    });

    /**
     * 5Ô∏è‚É£ Calcular posi√ß√µes (empate real)
     */
    let position = 1;
    let lastScoreTotal: number | null = null;
    let lastScoreRound: number | null = null;
    let index = 0;

    return ranking.map(item => {
      index++;

      if (
        lastScoreTotal !== null &&
        (item.scoreTotal !== lastScoreTotal ||
          item.scoreRound !== lastScoreRound)
      ) {
        position = index;
      }

      lastScoreTotal = item.scoreTotal;
      lastScoreRound = item.scoreRound;

      return {
        ...item,
        position,
      };
    });
  }
}
</file>

<file path="src/services/ranking/persist-ranking.service.ts">
import { prisma } from '../../lib/prisma';
import { CalculateRankingService } from './calculate-ranking.service';

interface PersistRankingInput {
  rankingId: string;
  rankingStartDate: Date;
  rankingEndDate: Date;
}

export class PersistRankingService {
  private calculateService = new CalculateRankingService();

  async execute(input: PersistRankingInput): Promise<void> {
    const { rankingId, rankingStartDate, rankingEndDate } = input;

    const results = await this.calculateService.execute({
      rankingStartDate,
      rankingEndDate
    });

    // Ordena√ß√£o determin√≠stica (crit√©rio j√° definido)
    const ordered = results.sort((a, b) => {
      if (b.rankingScore !== a.rankingScore) {
        return b.rankingScore - a.rankingScore;
      }

      if (b.lastScoreRound !== a.lastScoreRound) {
        return b.lastScoreRound - a.lastScoreRound;
      }

      return a.lastScoreDate.getTime() - b.lastScoreDate.getTime();
    });

    let position = 1;

    for (const item of ordered) {
      await prisma.rankingParticipant.upsert({
        where: {
          rankingId_userId: {
            rankingId,
            userId: item.userId
          }
        },
        update: {
          score: item.rankingScore,
          scoreInitial: item.scoreInitial,
          position
        },
        create: {
          rankingId,
          userId: item.userId,
          score: item.rankingScore,
          scoreInitial: item.scoreInitial,
          position
        }
      });

      position++;
    }
  }
}
</file>

<file path="src/services/ranking/snapshot-ranking.service.ts">
import { prisma } from '../../lib/prisma';

type SnapshotRow = {
  userId: string;
  scoreTotal: number;
  scoreRound: number;
};

export class SnapshotRankingService {
  static async execute(roundId: string): Promise<void> {
    /**
     * 1Ô∏è‚É£ Validar rodada
     */
    const round = await prisma.round.findUnique({
      where: { id: roundId },
      select: { id: true, status: true },
    });

    if (!round) {
      throw new Error('Round not found');
    }

    if (round.status !== 'SCORED') {
      throw new Error('Snapshot can only be generated for SCORED rounds');
    }

    /**
     * 2Ô∏è‚É£ Garantir idempot√™ncia
     * (snapshot nunca pode ser gerado duas vezes)
     */
    const snapshotExists = await prisma.rankingSnapshot.findFirst({
      where: { roundId },
      select: { id: true },
    });

    if (snapshotExists) {
      throw new Error('Snapshot already generated for this round');
    }

    /**
     * 3Ô∏è‚É£ Buscar score acumulado por usu√°rio AT√â esta rodada
     */
    const history = await prisma.userScoreHistory.groupBy({
      by: ['userId'],
      where: {
        roundId: {
          lte: roundId,
        },
      },
      _max: {
        scoreTotal: true,
      },
    });

    if (history.length === 0) {
      return;
    }

    /**
     * 4Ô∏è‚É£ Buscar score da rodada atual (para desempate)
     */
    const roundScores = await prisma.userScoreHistory.findMany({
      where: { roundId },
      select: {
        userId: true,
        scoreRound: true,
      },
    });

    const roundScoreMap = new Map<string, number>();
    roundScores.forEach(r => {
      roundScoreMap.set(r.userId, r.scoreRound);
    });

    /**
     * 5Ô∏è‚É£ Normalizar dados
     */
    const rows: SnapshotRow[] = history.map(h => ({
      userId: h.userId,
      scoreTotal: h._max.scoreTotal ?? 0,
      scoreRound: roundScoreMap.get(h.userId) ?? 0,
    }));

    /**
     * 6Ô∏è‚É£ Ordena√ß√£o + desempates (CONGELADO)
     */
    rows.sort((a, b) => {
      if (b.scoreTotal !== a.scoreTotal) {
        return b.scoreTotal - a.scoreTotal;
      }

      if (b.scoreRound !== a.scoreRound) {
        return b.scoreRound - a.scoreRound;
      }

      return a.userId.localeCompare(b.userId);
    });

    /**
     * 7Ô∏è‚É£ Calcular posi√ß√µes (empate real)
     */
    let currentPosition = 1;
    let lastScoreTotal: number | null = null;
    let lastScoreRound: number | null = null;
    let index = 0;

    const snapshots = rows.map(row => {
      index++;

      if (
        lastScoreTotal !== null &&
        (row.scoreTotal !== lastScoreTotal ||
          row.scoreRound !== lastScoreRound)
      ) {
        currentPosition = index;
      }

      lastScoreTotal = row.scoreTotal;
      lastScoreRound = row.scoreRound;

      return {
        roundId,
        userId: row.userId,
        scoreTotal: row.scoreTotal,
        scoreRound: row.scoreRound,
        position: currentPosition,
        snapshotType: 'GLOBAL',
        periodRef: null,
      };
    });

    /**
     * 8Ô∏è‚É£ Persistir snapshot (INSERT ONLY)
     */
    await prisma.rankingSnapshot.createMany({
      data: snapshots,
    });
  }
}
</file>

<file path="src/services/round/close-round.service.ts">
import { RoundRepository } from '../../repositories/round.repository';
import { RoundStatus } from '@prisma/client';

export class CloseRoundService {
  private repository = new RoundRepository();

  async execute(roundId: string) {
    const round = await this.repository.findById(roundId);

    if (!round) {
      throw new Error('Rodada n√£o encontrada');
    }

    if (round.status !== RoundStatus.OPEN) {
      throw new Error('Somente rodadas OPEN podem ser fechadas');
    }

    return this.repository.updateStatus(roundId, RoundStatus.CLOSED);
  }
}
</file>

<file path="src/services/round/create-round.service.ts">
import { RoundRepository } from '../../repositories/round.repository';

export class CreateRoundService {
  private repository = new RoundRepository();

  async execute(params: {
    openAt: Date;
    closeAt: Date;
  }) {
    const { openAt, closeAt } = params;

    if (openAt >= closeAt) {
      throw new Error('openAt deve ser anterior a closeAt');
    }

    const lastNumber = await this.repository.getLastRoundNumber();
    const nextNumber = lastNumber + 1;

    // Nome derivado (n√£o persistido)
    const displayName = `Rodada ${String(nextNumber).padStart(3, '0')}`;

    const round = await this.repository.create({
      number: nextNumber,
      openAt,
      closeAt
    });

    return {
      ...round,
      displayName
    };
  }
}
</file>

<file path="src/services/round/open-round.service.ts">
import { RoundRepository } from '../../repositories/round.repository';
import { RoundStatus } from '@prisma/client';

export class OpenRoundService {
  private repository = new RoundRepository();

  async execute(roundId: string) {
    const openRound = await this.repository.findOpenRound();

    if (openRound) {
      throw new Error('J√° existe uma rodada aberta');
    }

    const round = await this.repository.findById(roundId);

    if (!round) {
      throw new Error('Rodada n√£o encontrada');
    }

    if (round.status !== RoundStatus.CLOSED) {
      throw new Error('Somente rodadas CLOSED podem ser reabertas');
    }

    return this.repository.updateStatus(roundId, RoundStatus.OPEN);
  }
}
</file>

<file path="src/services/score/calculate-ticket-score.service.ts">
export class CalculateTicketScoreService {
  execute(prediction: string, result: string): number {
    const isCorrect = prediction.startsWith(result);

    // Super Dupla
    if (prediction.endsWith('SD')) {
      return isCorrect ? 4 : -4;
    }

    // Dupla
    if (prediction.endsWith('D')) {
      return isCorrect ? 2 : -2;
    }

    // Simples
    return isCorrect ? 1 : 0;
  }
}
</file>

<file path="src/services/subscription/renew-subscription-from-payment.service.ts">
import { prisma } from '../../lib/prisma';
import { SubscriptionPlan, SubscriptionStatus } from '@prisma/client';

type Input = {
  userId: string;
  plan: SubscriptionPlan;
};

export class RenewSubscriptionFromPaymentService {
  static async execute({ userId, plan }: Input): Promise<void> {
    const subscription = await prisma.subscription.findUnique({
      where: { userId },
    });

    const now = new Date();

    const periodDays =
      plan === SubscriptionPlan.MONTHLY ? 30 : 365;

    const newEndAt = subscription?.endAt && subscription.endAt > now
      ? new Date(subscription.endAt.getTime() + periodDays * 86400000)
      : new Date(now.getTime() + periodDays * 86400000);

    if (!subscription) {
      await prisma.subscription.create({
        data: {
          userId,
          plan,
          status: SubscriptionStatus.ACTIVE,
          startAt: now,
          endAt: newEndAt,
        },
      });
      return;
    }

    await prisma.subscription.update({
      where: { userId },
      data: {
        plan,
        status: SubscriptionStatus.ACTIVE,
        endAt: newEndAt,
      },
    });
  }
}
</file>

<file path="src/services/subscription/revalidate-active-subscriptions.service.ts">
import { prisma } from '../../lib/prisma';
import { MercadoPagoClient } from '../../lib/mercado-pago.client';

/**
 * Revalida assinaturas ativas no Mercado Pago
 *
 * EXECU√á√ÉO:
 * - Job interno
 * - Pode rodar 1x ao dia
 *
 * FUN√á√ÉO:
 * - Corrigir estados inconsistentes
 * - Garantir que PRO esteja correto
 *
 * N√ÉO:
 * - N√£o cria pagamento
 * - N√£o credita wallet
 * - N√£o altera hist√≥rico
 */
export class RevalidateActiveSubscriptionsService {
  static async execute(): Promise<void> {
    if (!process.env.MP_ACCESS_TOKEN) {
      return;
    }

    const mpClient = new MercadoPagoClient(process.env.MP_ACCESS_TOKEN);

    /**
     * 1Ô∏è‚É£ Buscar assinaturas ativas locais (Mercado Pago)
     */
    const activeSubscriptions = await prisma.subscription.findMany({
      where: {
        provider: 'MERCADO_PAGO',
        status: 'ACTIVE',
        externalSubscriptionId: {
          not: null,
        },
      },
    });

    for (const subscription of activeSubscriptions) {
      try {
        /**
         * 2Ô∏è‚É£ Buscar estado real no MP
         */
        const mpSubscription = await mpClient.getSubscription(
          subscription.externalSubscriptionId!
        );

        /**
         * 3Ô∏è‚É£ Mapear status
         */
        const statusMap: Record<string, 'ACTIVE' | 'CANCELLED' | 'EXPIRED'> = {
          authorized: 'ACTIVE',
          paused: 'ACTIVE',
          cancelled: 'CANCELLED',
          expired: 'EXPIRED',
        };

        const mappedStatus =
          statusMap[mpSubscription.status] ?? 'EXPIRED';

        /**
         * 4Ô∏è‚É£ Atualizar assinatura se necess√°rio
         */
        if (mappedStatus !== subscription.status) {
          await prisma.subscription.update({
            where: {
              id: subscription.id,
            },
            data: {
              status: mappedStatus,
              endAt: mpSubscription.end_date
                ? new Date(mpSubscription.end_date)
                : subscription.endAt,
            },
          });

          /**
           * 5Ô∏è‚É£ Ajustar papel do usu√°rio
           */
          await prisma.user.update({
            where: { id: subscription.userId },
            data: {
              role: mappedStatus === 'ACTIVE' ? 'PRO' : 'NORMAL',
            },
          });
        }
      } catch (error) {
        /**
         * Falha pontual n√£o interrompe o job
         */
        console.error(
          `[SUBSCRIPTION REVALIDATE ERROR]`,
          subscription.id,
          error
        );
      }
    }
  }
}
</file>

<file path="src/services/subscription/subscription.service.ts">
import { prisma } from '../../lib/prisma';

export class SubscriptionService {
  static async createOrRenew(userId: string, plan: 'MONTHLY' | 'ANNUAL') {
    const startAt = new Date();
    const endAt = new Date(startAt);

    if (plan === 'MONTHLY') {
      endAt.setMonth(endAt.getMonth() + 1);
    } else {
      endAt.setFullYear(endAt.getFullYear() + 1);
    }

    return prisma.subscription.upsert({
      where: { userId },
      update: {
        plan,
        status: 'ACTIVE',
        startAt,
        endAt,
      },
      create: {
        userId,
        plan,
        status: 'ACTIVE',
        startAt,
        endAt,
      },
    });
  }

  static async isProActive(userId: string): Promise<boolean> {
    const sub = await prisma.subscription.findFirst({
      where: {
        userId,
        status: 'ACTIVE',
        endAt: { gt: new Date() },
      },
    });

    return !!sub;
  }
}
</file>

<file path="src/services/user-profile.service.ts">
import { UserRepository } from "../repositories/user.repository";

export class UserProfileService {
  private userRepository: UserRepository;

  constructor() {
    this.userRepository = new UserRepository();
  }

  async execute(userId: string) {
    if (!userId) {
      throw new Error("ID do usu√°rio n√£o informado");
    }

    const user = await this.userRepository.findById(userId);

    if (!user) {
      throw new Error("Usu√°rio n√£o encontrado");
    }

    return {
      id: user.id,
      name: user.name,
      nickname: user.nickname,
      email: user.email,
      cpf: user.cpf,
      phone: user.phone,
      role: user.role,
      createdAt: user.createdAt
    };
  }
}
</file>

<file path="src/services/user.service.ts">
import bcrypt from "bcryptjs";
import { UserRepository } from "../repositories/user.repository";
import { CreateUserSchema } from "../validators/createUser.validator";

export class UserService {
  private repository = new UserRepository();

  async createUser(payload: unknown) {
    const data = CreateUserSchema.parse(payload);

    const emailExists = await this.repository.findByEmail(data.email);
    if (emailExists) {
      throw new Error("Email j√° cadastrado");
    }

    const cpfExists = await this.repository.findByCpf(data.cpf);
    if (cpfExists) {
      throw new Error("CPF j√° cadastrado");
    }

    const hashedPassword = await bcrypt.hash(data.password, 10);

    const user = await this.repository.create({
      ...data,
      password: hashedPassword,
      role: "NORMAL"
    });

    return {
      id: user.id,
      name: user.name,
      nickname: user.nickname,
      email: user.email,
      role: user.role,
      createdAt: user.createdAt
    };
  }
}
</file>

<file path="src/utils/jwt.ts">
import jwt, { JwtPayload as JwtLibPayload, SignOptions } from 'jsonwebtoken';

// üîê Leitura expl√≠cita do secret
const rawSecret = process.env.JWT_SECRET;

// Valida√ß√£o em runtime
if (!rawSecret) {
  throw new Error('JWT_SECRET n√£o configurado no ambiente');
}

// ‚úÖ Normaliza√ß√£o de tipo (TypeScript)
const JWT_SECRET: string = rawSecret;

// Expira√ß√£o tipada corretamente
const JWT_EXPIRES_IN: SignOptions['expiresIn'] = '7d';

export interface JWTPayload {
  id: string;
  email: string;
  role: string;
}

/**
 * Gera token JWT
 */
export function generateToken(payload: JWTPayload): string {
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN
  });
}

/**
 * Verifica token JWT
 */
export function verifyToken(token: string): JWTPayload {
  const decoded = jwt.verify(token, JWT_SECRET) as JwtLibPayload;

  return {
    id: decoded.id as string,
    email: decoded.email as string,
    role: decoded.role as string
  };
}
</file>

<file path="src/validators/createUser.validator.ts">
import { z } from "zod";

export const CreateUserSchema = z.object({
  name: z.string().min(3),
  nickname: z.string().min(2),
  email: z.string().email(),
  cpf: z.string().min(11),
  phone: z.string().min(8),
  password: z.string().min(6)
});

export type CreateUserDTO = z.infer<typeof CreateUserSchema>;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Linguagem alvo */
    "target": "ES2020",

    /* Sistema de m√≥dulos */
    "module": "CommonJS",

    /* Diret√≥rios */
    "rootDir": "src",
    "outDir": "dist",

    /* Resolu√ß√£o de m√≥dulos */
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,

    /* Qualidade e seguran√ßa */
    "strict": true,
    "skipLibCheck": true,

    /* Debug controlado */
    "sourceMap": false
  },

  /* Runtime real da aplica√ß√£o */
  "include": [
    "src/**/*.ts"
  ],

  /* Nunca compilar */
  "exclude": [
    "node_modules",
    "dist",
    "prisma"
  ]
}
</file>

<file path=".dockerignore">
node_modules
dist
.git
.env

# üîí Prisma (garantir inclus√£o)
!prisma
!prisma/schema.prisma
!prisma/migrations
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output (NUNCA versionar)
dist/

# Environment variables
.env

# Prisma generated
/src/generated/prisma
</file>

<file path="prisma/migrations/20260120_bolao_ranking_model/migration.sql">
-- 1Ô∏è‚É£ Criar enum de status do ranking
CREATE TYPE "RankingStatus" AS ENUM (
  'DRAFT',
  'ACTIVE',
  'CLOSED'
);

-- 2Ô∏è‚É£ Alterar tabela rankings (incremental)
ALTER TABLE "rankings"
ADD COLUMN "status" "RankingStatus" NOT NULL DEFAULT 'DRAFT',
ADD COLUMN "maxParticipants" INTEGER,
ADD COLUMN "currentParticipants" INTEGER NOT NULL DEFAULT 0,
ADD COLUMN "durationDays" INTEGER,
ADD COLUMN "createdByUserId" TEXT;

-- 3Ô∏è‚É£ Relacionamento com usu√°rio criador do bol√£o
ALTER TABLE "rankings"
ADD CONSTRAINT "rankings_createdByUserId_fkey"
FOREIGN KEY ("createdByUserId")
REFERENCES "users"("id")
ON DELETE SET NULL;
</file>

<file path="prisma/migrations/20260120_monetizacao_core/migration.sql">
-- ENUMS
CREATE TYPE "SubscriptionPlan" AS ENUM ('MONTHLY', 'ANNUAL');
CREATE TYPE "SubscriptionStatus" AS ENUM ('ACTIVE', 'EXPIRED', 'CANCELLED');
CREATE TYPE "WalletTransactionType" AS ENUM ('CREDIT', 'DEBIT');

-- SUBSCRIPTIONS
CREATE TABLE "subscriptions" (
  "id" UUID PRIMARY KEY,
  "userId" TEXT NOT NULL,
  "plan" "SubscriptionPlan" NOT NULL,
  "status" "SubscriptionStatus" NOT NULL DEFAULT 'ACTIVE',
  "startAt" TIMESTAMP NOT NULL,
  "endAt" TIMESTAMP,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  "updatedAt" TIMESTAMP NOT NULL DEFAULT now()
);

ALTER TABLE "subscriptions"
ADD CONSTRAINT "subscriptions_userId_fkey"
FOREIGN KEY ("userId")
REFERENCES "users"("id")
ON DELETE CASCADE;

CREATE INDEX "subscriptions_userId_idx" ON "subscriptions"("userId");

-- WALLETS
CREATE TABLE "wallets" (
  "id" UUID PRIMARY KEY,
  "userId" TEXT NOT NULL UNIQUE,
  "balance" INTEGER NOT NULL DEFAULT 0,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  "updatedAt" TIMESTAMP NOT NULL DEFAULT now()
);

ALTER TABLE "wallets"
ADD CONSTRAINT "wallets_userId_fkey"
FOREIGN KEY ("userId")
REFERENCES "users"("id")
ON DELETE CASCADE;

-- WALLET LEDGER
CREATE TABLE "wallet_ledger" (
  "id" UUID PRIMARY KEY,
  "walletId" UUID NOT NULL,
  "type" "WalletTransactionType" NOT NULL,
  "amount" INTEGER NOT NULL,
  "description" TEXT,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now()
);

ALTER TABLE "wallet_ledger"
ADD CONSTRAINT "wallet_ledger_walletId_fkey"
FOREIGN KEY ("walletId")
REFERENCES "wallets"("id")
ON DELETE CASCADE;

CREATE INDEX "wallet_ledger_walletId_idx" ON "wallet_ledger"("walletId");

-- ROUND BENEFITS (FREE)
CREATE TABLE "round_benefits" (
  "id" UUID PRIMARY KEY,
  "userId" TEXT NOT NULL,
  "roundId" TEXT NOT NULL,
  "freeDoubles" INTEGER NOT NULL DEFAULT 0,
  "freeSuperDoubles" INTEGER NOT NULL DEFAULT 0,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
  UNIQUE ("userId", "roundId")
);

ALTER TABLE "round_benefits"
ADD CONSTRAINT "round_benefits_userId_fkey"
FOREIGN KEY ("userId")
REFERENCES "users"("id")
ON DELETE CASCADE;

ALTER TABLE "round_benefits"
ADD CONSTRAINT "round_benefits_roundId_fkey"
FOREIGN KEY ("roundId")
REFERENCES "rounds"("id")
ON DELETE CASCADE;

CREATE INDEX "round_benefits_roundId_idx" ON "round_benefits"("roundId");
</file>

<file path="src/controllers/internal-jobs.controller.ts">
import { Request, Response } from 'express';
import { CloseExpiredRankingsService } from '../services/ranking/close-expired-rankings.service';

export class InternalJobsController {
  async closeExpiredRankings(req: Request, res: Response) {
    const service = new CloseExpiredRankingsService();
    const result = await service.execute();

    return res.json({
      success: true,
      closed: result.closed
    });
  }
}
</file>

<file path="src/controllers/internal/close-expired-rankings.controller.ts">
import { Request, Response } from 'express';
import { prisma } from '../../lib/prisma';
import { CloseRankingService } from '../../services/ranking/close-ranking.service';

export class CloseExpiredRankingsController {
  async execute(req: Request, res: Response) {
    const token = req.headers['x-internal-job-token'];

    if (token !== process.env.INTERNAL_JOB_SECRET) {
      return res.status(401).json({ error: 'Unauthorized job execution' });
    }

    const expiredRankings = await prisma.ranking.findMany({
      where: {
        status: 'ACTIVE',
        endDate: {
          lt: new Date(),
        },
      },
      select: { id: true },
    });

    const service = new CloseRankingService();

    for (const ranking of expiredRankings) {
      await service.execute(ranking.id);
    }

    return res.json({
      closedRankings: expiredRankings.length,
    });
  }
}
</file>

<file path="src/controllers/internal/subscription-jobs.controller.ts">
import { Request, Response } from 'express';
import { RevalidateActiveSubscriptionsService } from '../../services/subscription/revalidate-active-subscriptions.service';

export class SubscriptionJobsController {
  static async revalidate(_req: Request, res: Response) {
    const timestamp = new Date().toISOString();

    console.info({
      level: 'INFO',
      service: 'SubscriptionJobsController',
      action: 'job.revalidate.start',
      message: 'In√≠cio do job de revalida√ß√£o de assinaturas',
      timestamp,
    });

    await RevalidateActiveSubscriptionsService.execute();

    console.info({
      level: 'INFO',
      service: 'SubscriptionJobsController',
      action: 'job.revalidate.finish',
      message: 'Job de revalida√ß√£o conclu√≠do',
      timestamp,
    });

    return res.status(200).json({ status: 'ok' });
  }
}
</file>

<file path="src/controllers/ranking/monthly-ranking.controller.ts">
import { Request, Response, NextFunction } from 'express';
import { prisma } from '../../lib/prisma';

export class MonthlyRankingController {
  static async handle(req: Request, res: Response, next: NextFunction) {
    try {
      /**
       * üîπ 1. Usu√°rio autenticado
       * Middleware de auth j√° garantiu req.user
       */
      const userId = (req as any).user?.id;

      /**
       * üîπ 2. Buscar ranking mensal ativo (GLOBAL)
       */
      const ranking = await prisma.ranking.findFirst({
        where: {
          type: 'GLOBAL',
          status: 'ACTIVE',
        },
        select: {
          id: true,
          name: true,
          type: true,
          status: true,
          startDate: true,
          endDate: true,
          createdAt: true,
        },
      });

      /**
       * üîπ 3. Se n√£o existir ranking ativo
       */
      if (!ranking) {
        return res.json({
          ranking: null,
          participants: [],
          me: null,
        });
      }

      /**
       * üîπ 4. Determinar periodRef (YYYY-MM)
       * Usa startDate do ranking como refer√™ncia
       */
      const refDate = ranking.startDate ?? new Date();
      const year = refDate.getUTCFullYear();
      const month = String(refDate.getUTCMonth() + 1).padStart(2, '0');
      const periodRef = `${year}-${month}`;

      /**
       * üîπ 5. Buscar snapshot do usu√°rio autenticado
       * Leitura pura, sem ordena√ß√£o, sem c√°lculo
       */
      let me = null;

      if (userId) {
        const snapshot = await prisma.rankingSnapshot.findFirst({
          where: {
            userId,
            snapshotType: 'GLOBAL',
            periodRef,
          },
          select: {
            position: true,
            scoreTotal: true,
          },
        });

        if (snapshot) {
          me = {
            isParticipant: true,
            position: snapshot.position,
            score: snapshot.scoreTotal,
          };
        } else {
          me = {
            isParticipant: false,
            position: null,
            score: null,
          };
        }
      }

      /**
       * üîπ 6. Payload final (incremental e compat√≠vel)
       */
      return res.json({
        ranking,
        participants: [],
        me,
      });
    } catch (err) {
      next(err);
    }
  }
}
</file>

<file path="src/lib/mercado-pago.client.ts">
import axios from 'axios';

export class MercadoPagoClient {
  constructor(private readonly accessToken: string) {}

  async getPayment(paymentId: string) {
    const response = await axios.get(
      `https://api.mercadopago.com/v1/payments/${paymentId}`,
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      }
    );

    return response.data;
  }

  async getSubscription(subscriptionId: string) {
    const response = await axios.get(
      `https://api.mercadopago.com/preapproval/${subscriptionId}`,
      {
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
        },
      }
    );

    return response.data;
  }
}
</file>

<file path="src/repositories/ranking.repository.ts">
import { prisma } from '../lib/prisma';

export class RankingRepository {

  async listByRankingId(rankingId: string) {
    return prisma.rankingParticipant.findMany({
      where: { rankingId },
      orderBy: [
        { position: 'asc' },
        { createdAt: 'asc' } // fallback determin√≠stico para evitar sort inst√°vel
      ],
      select: {
        position: true,
        score: true,
        scoreInitial: true,
        user: {
          select: {
            id: true,
            name: true,
            nickname: true,
            profileImage: true
          }
        }
      }
    });
  }

}
</file>

<file path="src/routes/index.ts">
import { Router } from 'express';
import internalRoutes from './internal';

const router = Router();

router.use('/internal', internalRoutes);

export default router;
</file>

<file path="src/routes/internal/jobs.routes.ts">
import { Router } from 'express';
import { internalJobAuth } from '../../middleware/internal-job-auth.middleware';
import { ScoreRoundJobController } from '../../controllers/internal/score-round.job.controller';
import { CloseExpiredRankingsController } from '../../controllers/internal/close-expired-rankings.controller';

const router = Router();

const scoreRoundController = new ScoreRoundJobController();
const closeExpiredRankingsController = new CloseExpiredRankingsController();

router.post(
  '/score-round',
  internalJobAuth,
  (req, res) => scoreRoundController.execute(req, res)
);

router.post(
  '/close-expired-rankings',
  internalJobAuth,
  (req, res) => closeExpiredRankingsController.execute(req, res)
);

export default router;
</file>

<file path="src/routes/internal/mercado-pago.routes.ts">
import { Router } from 'express';
import { MercadoPagoWebhookController } from '../../controllers/internal/mercado-pago-webhook.controller';

const router = Router();

router.post('/webhooks/mercado-pago', MercadoPagoWebhookController.handle);

export default router;
</file>

<file path="src/routes/ticket.routes.ts">
import { Router } from 'express';
import { TicketController } from '../controllers/ticket.controller';

const router = Router();

//
// POST /tickets
// Cria√ß√£o / atualiza√ß√£o de bilhete com monetiza√ß√£o integrada
//
router.post('/tickets', TicketController.create);

export default router;
</file>

<file path="src/services/admin/get-subscription.service.ts">
import { prisma } from '../../lib/prisma';

/**
 * Service READ-ONLY para recupera√ß√£o de assinatura
 *
 * Objetivo:
 * - Centralizar leitura de assinatura
 * - Evitar duplica√ß√£o em jobs e alertas
 * - N√ÉO altera estado
 * - N√ÉO aplica regra de neg√≥cio
 */
export class GetSubscriptionService {
  static async byUserId(userId: string) {
    return prisma.subscription.findUnique({
      where: { userId },
      include: {
        user: {
          select: {
            id: true,
            role: true,
          },
        },
      },
    });
  }

  static async bySubscriptionId(subscriptionId: string) {
    return prisma.subscription.findUnique({
      where: { id: subscriptionId },
      include: {
        user: {
          select: {
            id: true,
            role: true,
          },
        },
      },
    });
  }
}
</file>

<file path="src/services/bolao/create-bolao.service.ts">
import { prisma } from '../../lib/prisma';
import { randomUUID } from 'crypto';

type CreateBolaoInput = {
  name: string;
  description?: string;
  maxParticipants?: number; // default 50
  durationDays: number;     // ex: 30, 60, 90
  createdByUserId: string;
};

export class CreateBolaoService {
  static async execute(input: CreateBolaoInput) {
    const {
      name,
      description,
      maxParticipants = 50,
      durationDays,
      createdByUserId,
    } = input;

    /**
     * 1Ô∏è‚É£ Validar usu√°rio PRO
     */
    const user = await prisma.user.findUnique({
      where: { id: createdByUserId },
      select: { id: true, role: true },
    });

    if (!user) {
      throw new Error('User not found');
    }

    if (user.role !== 'PRO') {
      throw new Error('Only PRO users can create bol√£o');
    }

    /**
     * 2Ô∏è‚É£ Validar par√¢metros
     */
    if (!name || name.trim().length < 3) {
      throw new Error('Bol√£o name must have at least 3 characters');
    }

    if (durationDays <= 0) {
      throw new Error('durationDays must be greater than zero');
    }

    if (maxParticipants !== 50) {
      // regra congelada neste bloco
      throw new Error('maxParticipants must be 50');
    }

    /**
     * 3Ô∏è‚É£ Transa√ß√£o at√¥mica
     */
    const result = await prisma.$transaction(async tx => {
      /**
       * 3.1 Criar Ranking (Bol√£o) em DRAFT
       */
      const bolao = await tx.ranking.create({
        data: {
          id: randomUUID(), // ‚úÖ INCREMENTO M√çNIMO
          name,
          description,
          type: 'BOLAO',
          status: 'DRAFT',
          maxParticipants,
          currentParticipants: 0,
          durationDays,
          createdByUserId,
        },
      });

      /**
       * 3.2 Criador entra automaticamente como participante
       */
      await tx.rankingParticipant.create({
        data: {
          rankingId: bolao.id,
          userId: createdByUserId,
          score: 0,
          scoreInitial: 0,
        },
      });

      /**
       * 3.3 Atualizar contador de participantes
       */
      const updatedBolao = await tx.ranking.update({
        where: { id: bolao.id },
        data: {
          currentParticipants: 1,
        },
      });

      return updatedBolao;
    });

    /**
     * 4Ô∏è‚É£ Retorno controlado
     */
    return {
      id: result.id,
      name: result.name,
      status: result.status,
      maxParticipants: result.maxParticipants,
      currentParticipants: result.currentParticipants,
      durationDays: result.durationDays,
    };
  }
}
</file>

<file path="src/services/ranking/assert-can-add-participant.service.ts">
import { prisma } from '../../lib/prisma';

export class AssertCanAddParticipantService {
  async execute(rankingId: string) {
    const ranking = await prisma.ranking.findUnique({
      where: { id: rankingId },
      select: {
        id: true,
        status: true,
        type: true,
      },
    });

    if (!ranking) {
      throw new Error('Ranking n√£o encontrado');
    }

    if (ranking.status !== 'ACTIVE') {
      throw new Error('Ranking inativo ou expirado');
    }

    // Enum congelado: GLOBAL | PRO | BOLAO
    return true;
  }
}
</file>

<file path="src/services/ranking/close-expired-rankings.service.ts">
import { prisma } from '../../lib/prisma';

export class CloseExpiredRankingsService {
  async execute(): Promise<{ closed: number }> {
    const now = new Date();

    const result = await prisma.ranking.updateMany({
      where: {
        status: 'ACTIVE',
        endDate: {
          not: null,
          lt: now,
        },
      },
      data: {
        status: 'CLOSED',
        updatedAt: now,
      },
    });

    return { closed: result.count };
  }
}
</file>

<file path="src/services/ranking/close-ranking.service.ts">
import { prisma } from '../../lib/prisma';

export class CloseRankingService {
  async execute(rankingId: string) {
    const ranking = await prisma.ranking.findUnique({
      where: { id: rankingId },
      include: {
        participants: true,
      },
    });

    if (!ranking) {
      throw new Error('Ranking n√£o encontrado');
    }

    if (ranking.status !== 'ACTIVE') {
      throw new Error('Ranking j√° est√° encerrado');
    }

    if (!ranking.endDate || ranking.endDate > new Date()) {
      throw new Error('Ranking ainda n√£o expirou');
    }

    const results: {
      participantId: string;
      userId: string;
      scoreRanking: number;
      scoreFinal: number;
    }[] = [];

    for (const participant of ranking.participants) {
      const lastHistory = await prisma.userScoreHistory.findFirst({
        where: {
          userId: participant.userId,
          createdAt: {
            lte: ranking.endDate,
          },
        },
        orderBy: { createdAt: 'desc' },
      });

      const scoreFinal = lastHistory?.scoreTotal ?? participant.scoreInitial;
      const scoreRanking = scoreFinal - participant.scoreInitial;

      results.push({
        participantId: participant.id,
        userId: participant.userId,
        scoreRanking,
        scoreFinal,
      });
    }

    results.sort((a, b) => {
      if (b.scoreRanking !== a.scoreRanking) {
        return b.scoreRanking - a.scoreRanking;
      }
      if (b.scoreFinal !== a.scoreFinal) {
        return b.scoreFinal - a.scoreFinal;
      }
      return 0;
    });

    await prisma.$transaction(async (tx) => {
      for (let i = 0; i < results.length; i++) {
        await tx.rankingParticipant.update({
          where: { id: results[i].participantId },
          data: {
            score: results[i].scoreRanking,
            position: i + 1,
          },
        });
      }

      await tx.ranking.update({
        where: { id: rankingId },
        data: {
          status: 'CLOSED',
        },
      });
    });
  }
}
</file>

<file path="src/services/ranking/CloseRankingService.ts">
import { prisma } from "../../lib/prisma";

export class CloseRankingService {
  async execute(rankingId: string): Promise<void> {
    const ranking = await prisma.ranking.findUnique({
      where: { id: rankingId },
      include: {
        participants: {
          include: {
            user: {
              include: {
                scoreHistory: {
                  orderBy: { createdAt: "desc" },
                  take: 1,
                },
              },
            },
          },
        },
        rounds: {
          orderBy: { createdAt: "desc" },
          take: 1,
        },
      },
    });

    if (!ranking || ranking.status !== 'ACTIVE') {
      return;
    }

    const ordered = ranking.participants.sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;

      const aLast = a.user.scoreHistory[0]?.scoreRound ?? 0;
      const bLast = b.user.scoreHistory[0]?.scoreRound ?? 0;
      if (bLast !== aLast) return bLast - aLast;

      const aDate = a.user.scoreHistory[0]?.createdAt.getTime() ?? 0;
      const bDate = b.user.scoreHistory[0]?.createdAt.getTime() ?? 0;
      return aDate - bDate;
    });

    for (let i = 0; i < ordered.length; i++) {
      await prisma.rankingParticipant.update({
        where: { id: ordered[i].id },
        data: {
          position: i + 1,
        },
      });
    }

    await prisma.ranking.update({
      where: { id: rankingId },
      data: {
        status: 'CLOSED',
      },
    });
  }
}
</file>

<file path="src/services/ranking/create-ranking.service.ts">
import { prisma } from '../../lib/prisma';
import { RankingType, UserRole } from '@prisma/client';
import { randomUUID } from 'crypto';

interface CreateRankingInput {
  name: string;
  description?: string;
  type: RankingType;
  startDate: Date;
  endDate?: Date;
  participantIds: string[];
}

export class CreateRankingService {
  async execute(input: CreateRankingInput) {
    // 1Ô∏è‚É£ Valida√ß√µes b√°sicas
    if (input.type === RankingType.BOLAO) {
      if (!input.endDate) {
        throw new Error('Ranking BOLAO exige data final');
      }

      if (input.participantIds.length === 0) {
        throw new Error('Ranking BOLAO exige participantes');
      }
    }

    // 2Ô∏è‚É£ Valida√ß√£o de usu√°rios PRO
    if (input.type === RankingType.BOLAO || input.type === RankingType.PRO) {
      const users = await prisma.user.findMany({
        where: {
          id: { in: input.participantIds },
          role: UserRole.PRO
        }
      });

      if (users.length !== input.participantIds.length) {
        throw new Error('Apenas usu√°rios PRO podem participar deste ranking');
      }
    }

    // 3Ô∏è‚É£ Cria√ß√£o do ranking
    const ranking = await prisma.ranking.create({
      data: {
        id: randomUUID(), // ‚úÖ INCREMENTO M√çNIMO
        name: input.name,
        description: input.description,
        type: input.type,
        startDate: input.startDate,
        endDate: input.endDate
      }
    });

    // 4Ô∏è‚É£ Cria√ß√£o dos participantes com scoreInitial
    for (const userId of input.participantIds) {
      const lastScore = await prisma.userScoreHistory.findFirst({
        where: {
          userId,
          createdAt: {
            lt: input.startDate
          }
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      const scoreInitial = lastScore?.scoreTotal ?? 0;

      await prisma.rankingParticipant.create({
        data: {
          rankingId: ranking.id,
          userId,
          scoreInitial,
          score: 0
        }
      });
    }

    return ranking;
  }
}
</file>

<file path="src/services/round/score-round.service.ts">
import { prisma } from '../../lib/prisma';
import { RoundRepository } from '../../repositories/round.repository';
import { TicketRepository } from '../../repositories/ticket.repository';
import { UserScoreHistoryRepository } from '../../repositories/user-score-history.repository';
import { RoundStatus, TicketStatus } from '@prisma/client';

export class ScoreRoundService {
  private roundRepo = new RoundRepository();
  private ticketRepo = new TicketRepository();
  private historyRepo = new UserScoreHistoryRepository();

  /**
   * Apura a rodada:
   * - bloqueia reapura√ß√£o
   * - calcula score de cada ticket
   * - persiste scoreRound no ticket
   * - gera hist√≥rico cumulativo por usu√°rio
   * - marca a rodada como SCORED
   */
  async execute(roundId: string): Promise<void> {
    const round = await this.roundRepo.findById(roundId);

    if (!round) {
      throw new Error('Rodada n√£o encontrada');
    }

    if (round.status === RoundStatus.SCORED) {
      throw new Error('Rodada j√° apurada (SCORED)');
    }

    if (round.status !== RoundStatus.CLOSED) {
      throw new Error('Rodada n√£o est√° fechada para apura√ß√£o');
    }

    if (!round.result) {
      throw new Error('Resultado da rodada n√£o informado');
    }

    const tickets = await this.ticketRepo.findByRound(roundId);
    const resultArray = round.result.split('-');

    await prisma.$transaction(async () => {
      for (const ticket of tickets) {
        const predictionArray = ticket.prediction.split('-');

        let scoreRound = 0;

        predictionArray.forEach((prediction: string, index: number) => {
          if (prediction === resultArray[index]) {
            scoreRound += 1;
          }
        });

        // Atualiza score do ticket
        await this.ticketRepo.updateScore(ticket.id, scoreRound);

        // Define status do ticket
        const status =
          scoreRound > 0 ? TicketStatus.WON : TicketStatus.LOST;

        await this.ticketRepo.updateStatus(ticket.id, status);

        // Busca √∫ltimo score acumulado do usu√°rio
        const lastHistory = await this.historyRepo.findLastByUser(ticket.userId);
        const lastTotal = lastHistory ? lastHistory.scoreTotal : 0;

        // Cria hist√≥rico cumulativo
        await this.historyRepo.create({
          userId: ticket.userId,
          roundId,
          scoreRound,
          scoreTotal: lastTotal + scoreRound
        });
      }

      // Marca rodada como apurada (estado final)
      await this.roundRepo.updateStatus(roundId, RoundStatus.SCORED);
    });
  }
}
</file>

<file path="src/services/score/score-round.service.ts">
import { prisma } from '../../lib/prisma';
import { RoundStatus, TicketStatus } from '@prisma/client';
import { CalculateTicketScoreService } from './calculate-ticket-score.service';

export class ScoreRoundService {
  private calculator = new CalculateTicketScoreService();

  /**
   * Executa a apura√ß√£o oficial de uma rodada.
   * ‚ö†Ô∏è Deve ser chamado EXCLUSIVAMENTE por job interno.
   */
  async execute(roundId: string): Promise<void> {
    await prisma.$transaction(async (tx) => {
      // 1Ô∏è‚É£ Carregar rodada e tickets
      const round = await tx.round.findUnique({
        where: { id: roundId },
        include: {
          tickets: true,
        },
      });

      if (!round) {
        throw new Error('Rodada n√£o encontrada');
      }

      // üîí Idempot√™ncia absoluta
      if (round.status === RoundStatus.SCORED) {
        return;
      }

      if (round.status !== RoundStatus.CLOSED) {
        throw new Error('Somente rodadas CLOSED podem ser apuradas');
      }

      if (!round.result) {
        throw new Error('Resultado da rodada n√£o definido');
      }

      // 2Ô∏è‚É£ Processar tickets
      for (const ticket of round.tickets) {
        const scoreRound = this.calculator.execute(
          ticket.prediction,
          round.result
        );

        const status =
          scoreRound > 0 ? TicketStatus.WON : TicketStatus.LOST;

        // 3Ô∏è‚É£ Atualizar ticket (resultado IMUT√ÅVEL)
        await tx.ticket.update({
          where: { id: ticket.id },
          data: {
            scoreRound,
            status,
          },
        });

        // 4Ô∏è‚É£ Buscar √∫ltimo score acumulado
        const lastHistory = await tx.userScoreHistory.findFirst({
          where: { userId: ticket.userId },
          orderBy: { createdAt: 'desc' },
        });

        const previousTotal = lastHistory?.scoreTotal ?? 0;
        const scoreTotal = previousTotal + scoreRound;

        // 5Ô∏è‚É£ Criar hist√≥rico (INSERT ONLY)
        await tx.userScoreHistory.create({
          data: {
            userId: ticket.userId,
            roundId,
            scoreRound,
            scoreTotal,
          },
        });
      }

      // 6Ô∏è‚É£ Finalizar rodada
      await tx.round.update({
        where: { id: roundId },
        data: {
          status: RoundStatus.SCORED,
        },
      });
    });
  }
}
</file>

<file path="src/services/subscription/activate-pro-from-payment.service.ts">
import { prisma } from '../../lib/prisma';
import { SubscriptionPlan, SubscriptionStatus } from '@prisma/client';

const PRICE_PLAN_MAP: Record<string, SubscriptionPlan> = {
  PRO_MONTHLY: SubscriptionPlan.MONTHLY,
  PRO_ANNUAL: SubscriptionPlan.ANNUAL,
};

const PLAN_DURATION_DAYS: Record<SubscriptionPlan, number> = {
  MONTHLY: 30,
  ANNUAL: 365,
};

export class ActivateProFromPaymentService {
  static async execute(params: {
    userId: string;
    priceId: string;
    paymentId: string;
  }) {
    const plan = PRICE_PLAN_MAP[params.priceId];
    if (!plan) return; // pagamento n√£o √© de PRO

    const now = new Date();
    const durationDays = PLAN_DURATION_DAYS[plan];

    const existing = await prisma.subscription.findUnique({
      where: { userId: params.userId },
    });

    if (!existing) {
      await prisma.subscription.create({
        data: {
          userId: params.userId,
          plan,
          status: SubscriptionStatus.ACTIVE,
          startAt: now,
          endAt: new Date(now.getTime() + durationDays * 86400000),
        },
      });
      return;
    }

    const baseDate =
      existing.status === SubscriptionStatus.ACTIVE && existing.endAt
        ? existing.endAt
        : now;

    await prisma.subscription.update({
      where: { userId: params.userId },
      data: {
        plan,
        status: SubscriptionStatus.ACTIVE,
        startAt: now,
        endAt: new Date(baseDate.getTime() + durationDays * 86400000),
      },
    });
  }
}
</file>

<file path="src/services/subscription/process-mp-subscription-cancelled.service.ts">
import { prisma } from '../../lib/prisma';
import { MercadoPagoClient } from '../../lib/mercado-pago.client';
import { randomUUID } from "crypto";

/**
 * Processa o evento subscription.cancelled do Mercado Pago
 *
 * REGRAS ABSOLUTAS:
 * - Webhook √© a √∫nica fonte da verdade
 * - Idempotente por externalEventId
 * - N√£o cria pagamentos
 * - N√£o credita wallet
 * - Cancela assinatura local
 * - Remove papel PRO
 * - Hist√≥rico preservado
 */
export class ProcessMpSubscriptionCancelledService {
  static async execute(event: any): Promise<void> {
    /**
     * 1Ô∏è‚É£ Valida√ß√£o m√≠nima do evento
     */
    const externalEventId: string | undefined = event?.id;
    const subscriptionId: string | undefined = event?.data?.id;

    if (!externalEventId || !subscriptionId) {
      return;
    }

    /**
     * 2Ô∏è‚É£ Idempot√™ncia ‚Äî evento j√° processado?
     */
    const alreadyProcessed = await prisma.paymentWebhookEvent.findUnique({
      where: {
        provider_externalEventId: {
          provider: 'MERCADO_PAGO',
          externalEventId,
        },
      },
    });

    if (alreadyProcessed) {
      return;
    }

    /**
     * 3Ô∏è‚É£ Buscar assinatura real no Mercado Pago
     */
    if (!process.env.MP_ACCESS_TOKEN) {
      return;
    }

    const mpClient = new MercadoPagoClient(process.env.MP_ACCESS_TOKEN);
    const mpSubscription = await mpClient.getSubscription(subscriptionId);

    /**
     * 4Ô∏è‚É£ Registrar evento bruto (append-only)
     */
    await prisma.paymentWebhookEvent.create({
      data: {
      id: randomUUID( ),
        provider: 'MERCADO_PAGO',
        externalEventId,
        payload: mpSubscription,
      },
    });

    /**
     * 5Ô∏è‚É£ Identificar usu√°rio
     *
     * REGRA FIXA:
     * external_reference = userId (Fantasy12)
     */
    const userId: string | undefined = mpSubscription.external_reference;
    if (!userId) {
      return;
    }

    /**
     * 6Ô∏è‚É£ Atualizar assinatura local para CANCELLED
     */
    await prisma.subscription.update({
      where: {
        userId,
      },
      data: {
        status: 'CANCELLED',
        endAt: mpSubscription.end_date
          ? new Date(mpSubscription.end_date)
          : new Date(),
      },
    });

    /**
     * 7Ô∏è‚É£ Rebaixar usu√°rio para NORMAL
     */
    await prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        role: 'NORMAL',
      },
    });
  }
}
</file>

<file path="src/services/subscription/process-mp-subscription-updated.service.ts">
import { prisma } from '../../lib/prisma';
import { MercadoPagoClient } from '../../lib/mercado-pago.client';
import { randomUUID } from "crypto";

/**
 * Processa o evento subscription.updated do Mercado Pago
 *
 * REGRAS ABSOLUTAS:
 * - Webhook √© a √∫nica fonte da verdade
 * - Idempotente por externalEventId
 * - N√£o cria pagamentos
 * - N√£o credita wallet
 * - Apenas sincroniza estado da assinatura
 * - Papel PRO depende do status
 */
export class ProcessMpSubscriptionUpdatedService {
  static async execute(event: any): Promise<void> {
    /**
     * 1Ô∏è‚É£ Valida√ß√£o m√≠nima do evento
     */
    const externalEventId: string | undefined = event?.id;
    const subscriptionId: string | undefined = event?.data?.id;

    if (!externalEventId || !subscriptionId) {
      return;
    }

    /**
     * 2Ô∏è‚É£ Idempot√™ncia ‚Äî evento j√° processado?
     */
    const alreadyProcessed = await prisma.paymentWebhookEvent.findUnique({
      where: {
        provider_externalEventId: {
          provider: 'MERCADO_PAGO',
          externalEventId,
        },
      },
    });

    if (alreadyProcessed) {
      return;
    }

    /**
     * 3Ô∏è‚É£ Buscar assinatura real no Mercado Pago
     */
    if (!process.env.MP_ACCESS_TOKEN) {
      return;
    }

    const mpClient = new MercadoPagoClient(process.env.MP_ACCESS_TOKEN);
    const mpSubscription = await mpClient.getSubscription(subscriptionId);

    /**
     * 4Ô∏è‚É£ Registrar evento bruto (append-only)
     */
    await prisma.paymentWebhookEvent.create({
      data: {
      id: randomUUID( ),
        provider: 'MERCADO_PAGO',
        externalEventId,
        payload: mpSubscription,
      },
    });

    /**
     * 5Ô∏è‚É£ Identificar usu√°rio
     *
     * REGRA FIXA:
     * external_reference = userId (Fantasy12)
     */
    const userId: string | undefined = mpSubscription.external_reference;
    if (!userId) {
      return;
    }

    /**
     * 6Ô∏è‚É£ Mapear status da assinatura
     */
    const statusMap: Record<string, 'ACTIVE' | 'CANCELLED' | 'EXPIRED'> = {
      authorized: 'ACTIVE',
      paused: 'ACTIVE',
      cancelled: 'CANCELLED',
      expired: 'EXPIRED',
    };

    const mappedStatus =
      statusMap[mpSubscription.status] ?? 'EXPIRED';

    /**
     * 7Ô∏è‚É£ Atualizar assinatura local
     */
    await prisma.subscription.update({
      where: {
        userId,
      },
      data: {
        status: mappedStatus,
        startAt: new Date(mpSubscription.start_date),
        endAt: mpSubscription.end_date
          ? new Date(mpSubscription.end_date)
          : null,
      },
    });

    /**
     * 8Ô∏è‚É£ Atualizar papel do usu√°rio conforme status
     */
    await prisma.user.update({
      where: {
        id: userId,
      },
      data: {
        role: mappedStatus === 'ACTIVE' ? 'PRO' : 'NORMAL',
      },
    });
  }
}
</file>

<file path="src/services/ticket/create-ticket.service.ts">
import { prisma } from '../../lib/prisma';
import { ConsumeBenefitsService } from '../benefits/consume-benefits.service';

type CreateTicketInput = {
  userId: string;
  roundId: string;
  prediction: string;
  useBenefit?: 'NONE' | 'DOUBLE' | 'SUPER_DOUBLE';
};

export class CreateTicketService {
  static async execute({
    userId,
    roundId,
    prediction,
    useBenefit = 'NONE',
  }: CreateTicketInput) {
    /**
     * 1Ô∏è‚É£ Validar rodada
     */
    const round = await prisma.round.findUnique({
      where: { id: roundId },
      select: { id: true, status: true },
    });

    if (!round || round.status !== 'OPEN') {
      throw new Error('Round is not open');
    }

    /**
     * 2Ô∏è‚É£ Consumir benef√≠cio (se solicitado)
     */
    if (useBenefit !== 'NONE') {
      await ConsumeBenefitsService.execute({
        userId,
        roundId,
        type: useBenefit,
      });
    }

    /**
     * 3Ô∏è‚É£ Criar ou atualizar bilhete
     */
    const ticket = await prisma.ticket.upsert({
      where: {
        userId_roundId: {
          userId,
          roundId,
        },
      },
      update: {
        prediction,
      },
      create: {
        userId,
        roundId,
        prediction,
      },
    });

    return {
      id: ticket.id,
      roundId: ticket.roundId,
      useBenefit,
      createdAt: ticket.createdAt,
    };
  }
}
</file>

<file path="src/services/wallet/wallet.service.ts">
import { prisma } from '../../lib/prisma';

export class WalletService {
  static async getOrCreateWallet(userId: string) {
    return prisma.wallet.upsert({
      where: { userId },
      update: {},
      create: { userId },
    });
  }

  static async credit(
    userId: string,
    amount: number,
    description?: string
  ) {
    return prisma.$transaction(async tx => {
      const wallet = await tx.wallet.upsert({
        where: { userId },
        update: {},
        create: { userId },
      });

      await tx.wallet.update({
        where: { id: wallet.id },
        data: { balance: { increment: amount } },
      });

      await tx.walletLedger.create({
        data: {
          walletId: wallet.id,
          type: 'CREDIT',
          amount,
          description,
        },
      });

      return wallet;
    });
  }

  static async debit(
    userId: string,
    amount: number,
    description?: string
  ) {
    return prisma.$transaction(async tx => {
      const wallet = await tx.wallet.findUnique({
        where: { userId },
      });

      if (!wallet || wallet.balance < amount) {
        throw new Error('Insufficient wallet balance');
      }

      await tx.wallet.update({
        where: { id: wallet.id },
        data: { balance: { decrement: amount } },
      });

      await tx.walletLedger.create({
        data: {
          walletId: wallet.id,
          type: 'DEBIT',
          amount,
          description,
        },
      });

      return wallet;
    });
  }
}
</file>

<file path="package.json">
{
  "name": "fantasy12-api",
  "version": "1.0.0",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js"
  },
  "prisma": {
    "seed": "node prisma/seed.js"
  },
  "dependencies": {
    "@prisma/client": "^5.11.0",
    "axios": "^1.13.2",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "zod": "^4.3.4"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/helmet": "^0.0.48",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.11.30",
    "prisma": "^5.11.0",
    "typescript": "^5.4.5"
  }
}
</file>

<file path="prisma/migrations/20260120_snapshot_ranking_v1_2/migration.sql">
-- ======================
-- RANKING SNAPSHOT
-- ======================

CREATE TABLE "ranking_snapshots" (
  "id" UUID NOT NULL,
  "roundId" TEXT NOT NULL,
  "userId" TEXT NOT NULL,

  "scoreTotal" INTEGER NOT NULL,
  "scoreRound" INTEGER NOT NULL,
  "position" INTEGER NOT NULL,

  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),

  CONSTRAINT "ranking_snapshots_pkey" PRIMARY KEY ("id"),

  CONSTRAINT "ranking_snapshots_roundId_fkey"
    FOREIGN KEY ("roundId")
    REFERENCES "rounds"("id")
    ON DELETE CASCADE,

  CONSTRAINT "ranking_snapshots_userId_fkey"
    FOREIGN KEY ("userId")
    REFERENCES "users"("id")
    ON DELETE CASCADE
);

CREATE UNIQUE INDEX "ranking_snapshots_roundId_userId_key"
  ON "ranking_snapshots" ("roundId", "userId");

CREATE INDEX "ranking_snapshots_roundId_idx"
  ON "ranking_snapshots" ("roundId");

CREATE INDEX "ranking_snapshots_userId_idx"
  ON "ranking_snapshots" ("userId");
</file>

<file path="src/controllers/internal/alerts-jobs.controller.ts">
import { Request, Response } from 'express';

import { DetectSubscriptionAlertsService } from '../../services/alerts/detect-subscription-anomalies.service';
import { DetectPaymentAlertsService } from '../../services/alerts/detect-payment-anomalies.service';
import { DetectWebhookAlertsService } from '../../services/alerts/detect-webhook-anomalies.service';
import { DetectJobAnomaliesService } from '../../services/alerts/detect-job-anomalies.service';

/**
 * Controller ‚Äî Jobs de Alertas Operacionais
 *
 * RESPONSABILIDADES:
 * - Orquestrar execu√ß√£o dos alertas
 * - Nenhuma regra de neg√≥cio
 * - Nenhuma escrita em banco
 *
 * BLOCO:
 * - v1.9 ‚Äî Alertas Operacionais
 */
export class AlertsJobsController {
  static async run(_req: Request, res: Response): Promise<Response> {
    const timestamp = new Date().toISOString();

    console.info({
      level: 'INFO',
      service: 'AlertsJobsController',
      action: 'alerts.run.start',
      message: 'In√≠cio da execu√ß√£o dos alertas operacionais',
      timestamp,
    });

    try {
      await DetectSubscriptionAlertsService.execute();
      await DetectPaymentAlertsService.execute();
      await DetectWebhookAlertsService.execute();
      await DetectJobAnomaliesService.execute();

      console.info({
        level: 'INFO',
        service: 'AlertsJobsController',
        action: 'alerts.run.finish',
        message: 'Execu√ß√£o dos alertas operacionais conclu√≠da',
        timestamp,
      });

      return res.status(200).json({ status: 'ok' });
    } catch (error) {
      console.error({
        level: 'CRITICAL',
        service: 'AlertsJobsController',
        action: 'alerts.run.error',
        message: 'Falha na execu√ß√£o dos alertas operacionais',
        error,
        timestamp,
      });

      return res.status(200).json({ status: 'error_logged' });
    }
  }
}
</file>

<file path="src/controllers/ranking.controller.ts">
import { Request, Response, NextFunction } from 'express';
import { GetRankingService } from '../services/ranking/get-ranking.service';
import { AddParticipantService } from '../services/ranking/add-participant.service';

export class RankingController {
  async show(req: Request, res: Response, next: NextFunction) {
    try {
      const { rankingId } = req.params;
      const service = new GetRankingService();
      const ranking = await service.execute(rankingId);
      return res.json(ranking);
    } catch (err) {
      next(err);
    }
  }

  async addParticipant(req: Request, res: Response, next: NextFunction) {
    try {
      const { rankingId } = req.params;
      const { userId } = req.body;

      const service = new AddParticipantService();
      const participant = await service.execute({
        rankingId,
        userId
      });

      return res.status(201).json(participant);
    } catch (err) {
      next(err);
    }
  }
}
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from '@prisma/client';

export const prisma = new PrismaClient();
</file>

<file path="src/middleware/internalJobAuth.ts">
import { Request, Response, NextFunction } from 'express';

export function internalJobAuth(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const token = req.headers['x-internal-job-token'];

  if (!token || token !== process.env.INTERNAL_JOB_TOKEN) {
    return res.status(401).json({
      error: 'Unauthorized internal job',
    });
  }

  return next();
}
</file>

<file path="src/routes/internal.routes.ts">
import { Router } from 'express';
import { internalJobAuth } from '../middleware/internalJobAuth';
import { GenerateRankingSnapshotController } from '../controllers/internal/generate-ranking-snapshot.controller';

const router = Router();

router.post(
  '/jobs/generate-ranking-snapshot',
  internalJobAuth,
  GenerateRankingSnapshotController.handle
);

export default router;
</file>

<file path="src/services/admin/admin-bolao.service.ts">
import { prisma } from '../../lib/prisma';
import { randomUUID } from 'crypto';

type CreateBolaoInput = {
  name: string;
  description?: string;
  startDate: Date;
  endDate: Date;
  durationDays: number;
  createdByUserId: string;
};

export class AdminBolaoService {
  /**
   * üîπ M√âTODO ANTIGO (PRESERVADO)
   * Usado por controllers antigos
   */
  static async create(adminId: string, input: CreateBolaoInput) {
    // regra antiga: admin cria bol√£o em nome de outro usu√°rio
    return this.execute({
      ...input,
      createdByUserId: input.createdByUserId ?? adminId,
    });
  }

  /**
   * üîπ M√âTODO ATUAL (L√ìGICA REAL)
   */
  static async execute(input: CreateBolaoInput) {
    const {
      name,
      description,
      startDate,
      endDate,
      durationDays,
      createdByUserId,
    } = input;

    return prisma.ranking.create({
      data: {
        id: randomUUID(), // incremento m√≠nimo j√° aprovado
        name,
        description,
        type: 'BOLAO',
        status: 'ACTIVE',
        startDate,
        endDate,
        durationDays,
        currentParticipants: 0,
        createdByUserId,
      },
    });
  }
}
</file>

<file path="src/services/payment/create-payment.service.ts">
import { prisma } from '../../lib/prisma'
import { randomUUID } from 'crypto'

export class CreatePaymentService {
  static async execute(params: {
    userId: string
    packageId: string
    method: 'PIX' | 'CARD'
  }) {
    const pkg = await prisma.paymentPackage.findUnique({
      where: { id: params.packageId },
    })

    if (!pkg || !pkg.isActive) {
      throw new Error('Invalid or inactive package')
    }

    const paymentId = randomUUID()
    const externalReference = `f12_${paymentId}`

    const payment = await prisma.payment.create({
      data: {
        id: paymentId,
        userId: params.userId,
        provider: 'MERCADO_PAGO',
        method: params.method,
        status: 'PENDING',
        packageId: pkg.id,
        amountCents: pkg.amountCents,
        coinsAmount: pkg.coinsAmount,
        bonusCoins: pkg.bonusCoins ?? 0,
        externalReference,
      },
    })

    return {
      paymentId: payment.id,
      externalPaymentId: payment.externalPaymentId,
      status: payment.status,
      checkoutUrl: null,
    }
  }
}
</file>

<file path="src/services/payment/list-payment-history.service.ts">
import { prisma } from '../../lib/prisma'

export class ListPaymentHistoryService {
  static async execute(userId: string) {
    const payments = await prisma.payment.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        status: true,
        amountCents: true,
        coinsAmount: true,
        method: true,
        provider: true,
        createdAt: true,
        //bonusCoins: true,
        }
    ,
    })

    return payments.map(payment => ({
      id: payment.id,
      status: payment.status,
      amountCents: payment.amountCents,
      coinsAmount: payment.coinsAmount,
      //bonusCoins: payment.bonusCoins,
      method: payment.method,
      provider: payment.provider,
      createdAt: payment.createdAt.toISOString(),
    }))
  }
}
</file>

<file path="src/services/ranking/add-participant.service.ts">
import { prisma } from '../../lib/prisma';
import { AppError } from '../../errors/AppError';

interface AddParticipantInput {
  rankingId: string;
  userId: string;
}

export class AddParticipantService {
  async execute(input: AddParticipantInput) {
    const ranking = await prisma.ranking.findUnique({
      where: { id: input.rankingId },
    });

    if (!ranking) {
      throw new AppError('Ranking n√£o encontrado', 404);
    }

    const now = new Date();

    if (ranking.startDate && now >= ranking.startDate) {
      throw new AppError(
        'Ranking j√° iniciado. N√£o √© poss√≠vel adicionar participantes.',
        409
      );
    }

    const exists = await prisma.rankingParticipant.findUnique({
      where: {
        rankingId_userId: {
          rankingId: input.rankingId,
          userId: input.userId,
        },
      },
    });

    if (exists) {
      throw new AppError('Usu√°rio j√° participa do ranking', 409);
    }

    const lastScore = await prisma.userScoreHistory.findFirst({
      where: {
        userId: input.userId,
        ...(ranking.startDate && {
          createdAt: {
            lt: ranking.startDate,
          },
        }),
      },
      orderBy: { createdAt: 'desc' },
    });

    const scoreInitial = lastScore?.scoreTotal ?? 0;

    return prisma.rankingParticipant.create({
      data: {
        rankingId: input.rankingId,
        userId: input.userId,
        scoreInitial,
        score: 0,
      },
    });
  }
}
</file>

<file path="src/services/subscription/process-mp-subscription-created.service.ts">
import { prisma } from '../../lib/prisma';
import { MercadoPagoClient } from '../../lib/mercado-pago.client';
import { randomUUID } from "crypto";

export class ProcessMpSubscriptionCreatedService {
  static async execute(event: any): Promise<void> {
    const timestamp = new Date().toISOString();
    const externalEventId = event?.id;
    const subscriptionId = event?.data?.id;

    if (!externalEventId || !subscriptionId) {
      console.warn({
        level: 'WARN',
        service: 'ProcessMpSubscriptionCreatedService',
        action: 'validation.failed',
        message: 'Evento inv√°lido',
        timestamp,
      });
      return;
    }

    const alreadyProcessed = await prisma.paymentWebhookEvent.findUnique({
      where: {
        provider_externalEventId: {
          provider: 'MERCADO_PAGO',
          externalEventId,
        },
      },
    });

    if (alreadyProcessed) {
      console.info({
        level: 'INFO',
        service: 'ProcessMpSubscriptionCreatedService',
        action: 'idempotency.hit',
        externalEventId,
        message: 'Evento j√° processado',
        timestamp,
      });
      return;
    }

    if (!process.env.MP_ACCESS_TOKEN) return;

    const mpClient = new MercadoPagoClient(process.env.MP_ACCESS_TOKEN);
    const mpSubscription = await mpClient.getSubscription(subscriptionId);

    await prisma.paymentWebhookEvent.create({
      data: {
        id: randomUUID(),
        provider: 'MERCADO_PAGO',
        externalEventId,
        payload: mpSubscription,
      },
    });

    const userId = mpSubscription.external_reference;
    if (!userId) return;

    const plan =
      mpSubscription.reason === 'Plano Anual' ? 'ANNUAL' : 'MONTHLY';

    await prisma.subscription.upsert({
      where: { userId },
      update: {
        plan,
        status: 'ACTIVE',
        provider: 'MERCADO_PAGO',
        externalSubscriptionId: mpSubscription.id,
        externalCustomerId: mpSubscription.payer_id,
        startAt: new Date(mpSubscription.start_date),
        endAt: mpSubscription.end_date
          ? new Date(mpSubscription.end_date)
          : null,
      },
      create: {
        userId,
        plan,
        status: 'ACTIVE',
        provider: 'MERCADO_PAGO',
        externalSubscriptionId: mpSubscription.id,
        externalCustomerId: mpSubscription.payer_id,
        startAt: new Date(mpSubscription.start_date),
        endAt: mpSubscription.end_date
          ? new Date(mpSubscription.end_date)
          : null,
      },
    });

    await prisma.user.update({
      where: { id: userId },
      data: { role: 'PRO' },
    });

    console.info({
      level: 'INFO',
      service: 'ProcessMpSubscriptionCreatedService',
      action: 'subscription.activated',
      subscriptionId: mpSubscription.id,
      userId,
      message: 'Assinatura ativada com sucesso',
      timestamp,
    });
  }
}
</file>

<file path="prisma/migrations/20260120_bolao_invites/migration.sql">
-- 1Ô∏è‚É£ Criar tabela bolao_invites
CREATE TABLE "bolao_invites" (
  "id" TEXT PRIMARY KEY,
  "rankingId" TEXT NOT NULL,
  "code" TEXT NOT NULL UNIQUE,

  "maxUses" INTEGER,
  "usedCount" INTEGER NOT NULL DEFAULT 0,

  "expiresAt" TIMESTAMP,
  "isActive" BOOLEAN NOT NULL DEFAULT true,

  "createdByUserId" TEXT NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now()
);

-- 2Ô∏è‚É£ FK para ranking (bol√£o)
ALTER TABLE "bolao_invites"
ADD CONSTRAINT "bolao_invites_rankingId_fkey"
FOREIGN KEY ("rankingId")
REFERENCES "rankings"("id")
ON DELETE CASCADE;

-- 3Ô∏è‚É£ FK para usu√°rio criador
ALTER TABLE "bolao_invites"
ADD CONSTRAINT "bolao_invites_createdByUserId_fkey"
FOREIGN KEY ("createdByUserId")
REFERENCES "users"("id")
ON DELETE CASCADE;

-- 4Ô∏è‚É£ √çndices auxiliares
CREATE INDEX "bolao_invites_rankingId_idx" ON "bolao_invites"("rankingId");
CREATE INDEX "bolao_invites_code_idx" ON "bolao_invites"("code");
</file>

<file path="prisma/migrations/20260122_v1_5_subscription_recorrente/migration.sql">
-- v1.5 ‚Äî assinatura recorrente (Mercado Pago) 
-- migration incremental, segura e idempotente 


ALTER TABLE "subscriptions" 
ADD COLUMN IF NOT EXISTS "provider" "PaymentProvider", 
ADD COLUMN IF NOT EXISTS "externalSubscriptionId" TEXT, 
ADD COLUMN IF NOT EXISTS "externalCustomerId" TEXT;
</file>

<file path="src/controllers/payment.controller.ts">
import { Request, Response } from 'express'
import { CreatePaymentService } from '../services/payment/create-payment.service'
import { ListPaymentHistoryService } from '../services/payment/list-payment-history.service'

class PaymentController {
  static async create(req: Request, res: Response) {
    const userId = (req as any).user?.id
    const { packageId, method } = req.body

    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' })
    }

    if (!packageId || !method) {
      return res.status(400).json({ error: 'packageId and method are required' })
    }

    const payment = await CreatePaymentService.execute({
      userId,
      packageId,
      method,
    })

    return res.status(201).json(payment)
  }

  static async history(req: Request, res: Response) {
    const userId = (req as any).user?.id

    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' })
    }

    const history = await ListPaymentHistoryService.execute(userId)
    return res.status(200).json(history)
  }
}

export default PaymentController
</file>

<file path="src/routes/internal/webhooks.routes.ts">
import { Router } from 'express';
import { MercadoPagoWebhookController } from '../../controllers/internal/mercado-pago-webhook.controller';

const router = Router();

/**
 * üîî Webhook Mercado Pago
 */
router.post(
  '/webhooks/mercado-pago',
  MercadoPagoWebhookController.handle
);

export default router;
</file>

<file path="src/services/payment/process-mercado-pago-webhook.service.ts">
import { prisma } from '../../lib/prisma';
import { MercadoPagoClient } from '../../lib/mercado-pago.client';
import {
  PaymentProvider,
  PaymentStatus,
  WalletTransactionType,
  Prisma,
  SubscriptionPlan,
} from '@prisma/client';
import { RenewSubscriptionFromPaymentService } from '../subscription/renew-subscription-from-payment.service';
import { randomUUID } from "crypto";

/**
 * Processa eventos de webhook do Mercado Pago.
 *
 * Regras:
 * - Webhook √© a √∫nica fonte de verdade
 * - Idempot√™ncia obrigat√≥ria
 * - Cr√©dito financeiro ocorre uma √∫nica vez
 * - Renova√ß√£o de assinatura ocorre somente ap√≥s cr√©dito confirmado
 */
export class ProcessMercadoPagoWebhookService {
  static async execute(event: any): Promise<void> {
    /**
     * 1Ô∏è‚É£ Valida√ß√£o m√≠nima do evento
     */
    const externalEventId = event?.id;
    const mpPaymentId = event?.data?.id;

    if (!externalEventId || !mpPaymentId) {
      return;
    }

    /**
     * 2Ô∏è‚É£ Idempot√™ncia
     */
    const alreadyProcessed =
      await prisma.paymentWebhookEvent.findUnique({
        where: {
          provider_externalEventId: {
            provider: PaymentProvider.MERCADO_PAGO,
            externalEventId,
          },
        },
      });

    if (alreadyProcessed) {
      return;
    }

    /**
     * 3Ô∏è‚É£ Buscar pagamento no Mercado Pago
     */
    if (!process.env.MP_ACCESS_TOKEN) {
      return;
    }

    const mpClient = new MercadoPagoClient(process.env.MP_ACCESS_TOKEN);
    const mpPayment = await mpClient.getPayment(mpPaymentId);

    /**
     * 4Ô∏è‚É£ Registrar evento (append-only)
     */
    await prisma.paymentWebhookEvent.create({
      data: {
      id: randomUUID(),
        provider: PaymentProvider.MERCADO_PAGO,
        externalEventId,
        payload: mpPayment,
      },
    });

    /**
     * 5Ô∏è‚É£ Localizar Payment interno
     */
    const payment = await prisma.payment.findFirst({
      where: {
        externalReference: mpPayment.external_reference ?? undefined,
      },
    });

    if (!payment || payment.isCredited) {
      return;
    }

    /**
     * 6Ô∏è‚É£ Pagamento n√£o aprovado ‚Üí apenas refletir status
     */
    if (mpPayment.status !== 'approved') {
      await prisma.payment.update({
        where: { id: payment.id },
        data: {
          status: this.mapMpStatus(mpPayment.status),
          externalPaymentId: mpPayment.id?.toString(),
        },
      });
      return;
    }

    /**
     * 7Ô∏è‚É£ Pagamento aprovado ‚Üí transa√ß√£o at√¥mica
     */
    await prisma.$transaction(async (tx: Prisma.TransactionClient) => {
      // Ledger (append-only)
      await tx.walletLedger.create({
        data: {
          wallet: { connect: { userId: payment.userId } },
          type: WalletTransactionType.CREDIT,
          amount: payment.coinsAmount,
          description: 'Pagamento aprovado via Mercado Pago',
        },
      });

      // Wallet
      await tx.wallet.update({
        where: { userId: payment.userId },
        data: {
          balance: { increment: payment.coinsAmount },
        },
      });

      // Payment
      await tx.payment.update({
        where: { id: payment.id },
        data: {
          status: PaymentStatus.APPROVED,
          isCredited: true,
          externalPaymentId: mpPayment.id?.toString(),
        },
      });
    });

    /**
     * 8Ô∏è‚É£ Renova√ß√£o autom√°tica da assinatura (v1.5)
     */
    const plan = mpPayment.metadata?.plan as SubscriptionPlan | undefined;

    if (plan === SubscriptionPlan.MONTHLY || plan === SubscriptionPlan.ANNUAL) {
      await RenewSubscriptionFromPaymentService.execute({
        userId: payment.userId,
        plan,
      });
    }
  }

  /**
   * Mapeia status do Mercado Pago ‚Üí PaymentStatus interno
   */
  private static mapMpStatus(mpStatus: string): PaymentStatus {
    switch (mpStatus) {
      case 'approved':
        return PaymentStatus.APPROVED;
      case 'rejected':
        return PaymentStatus.REJECTED;
      case 'cancelled':
        return PaymentStatus.CANCELLED;
      case 'refunded':
        return PaymentStatus.REFUNDED;
      default:
        return PaymentStatus.PENDING;
    }
  }
}
</file>

<file path="src/services/ranking/get-ranking.service.ts">
import { prisma } from '../../lib/prisma'
import { RankingRepository } from '../../repositories/ranking.repository'

export class GetRankingService {
  private rankingRepo = new RankingRepository()

  async execute(rankingId: string) {
    const ranking = await prisma.ranking.findUnique({
      where: { id: rankingId },
      select: {
        id: true,
        name: true,
        type: true,
        status: true,
        startDate: true,
        endDate: true,
        createdAt: true,
      },
    })

    /**
     * ‚ö†Ô∏è CONTRATO IMPORTANTE
     * Aus√™ncia de ranking N√ÉO √© erro t√©cnico
     * Deve retornar payload controlado
     */
    if (!ranking) {
      return {
        ranking: null,
        participants: [],
      }
    }

    const participants = await this.rankingRepo.listByRankingId(rankingId)

    return {
      ranking: {
        id: ranking.id,
        name: ranking.name,
        type: ranking.type,
        status: ranking.status,
        startDate: ranking.startDate,
        endDate: ranking.endDate,
        createdAt: ranking.createdAt,
      },
      participants,
    }
  }
}
</file>

<file path="Dockerfile">
############################
# STAGE 1 ‚Äî BUILD
############################
FROM node:20-bullseye AS build

WORKDIR /app

# Depend√™ncias do sistema
RUN apt-get update && apt-get install -y \
  openssl \
  ca-certificates \
  && rm -rf /var/lib/apt/lists/*

# Copiar package files
COPY package*.json ./

# Instalar TODAS as depend√™ncias (inclui dev)
RUN npm install

# Copiar c√≥digo
COPY . .

# Prisma Client (necess√°rio para build)
RUN npx prisma generate

# Build TypeScript
RUN npm run build


############################
# STAGE 2 ‚Äî RUNTIME
############################
FROM node:20-bullseye

WORKDIR /app

# Depend√™ncias m√≠nimas do sistema
RUN apt-get update && apt-get install -y \
  openssl \
  ca-certificates \
  && rm -rf /var/lib/apt/lists/*

# Copiar apenas o necess√°rio
COPY --from=build /app/package*.json ./
COPY --from=build /app/node_modules ./node_modules
COPY --from=build /app/dist ./dist
COPY --from=build /app/prisma ./prisma

# Prisma Client runtime
RUN npx prisma generate

EXPOSE 3001

# üîí Runtime startup:
# 1Ô∏è‚É£ aplica migrations
# 2Ô∏è‚É£ inicia a API
#CMD sh -c "npx prisma migrate deploy && node dist/index.js"
CMD ["node", "dist/index.js"]
</file>

<file path="src/routes/internal-jobs.routes.ts">
import { Router } from 'express';
import { InternalJobsController } from '../controllers/internal-jobs.controller';
import { ScoreRoundJobController } from '../controllers/internal/score-round.job.controller';
import { GenerateRankingSnapshotController } from '../controllers/internal/generate-ranking-snapshot.controller';
import { internalJobAuth } from '../middleware/internal-job-auth.middleware';

const router = Router();

//
// Controllers
//
const jobsController = new InternalJobsController();
const scoreRoundJobController = new ScoreRoundJobController();

//
// üîí JOB ‚Äî Fechar rankings expirados
// Uso interno (cron / scheduler)
//
router.post(
  '/jobs/close-expired-rankings',
  internalJobAuth,
  jobsController.closeExpiredRankings.bind(jobsController)
);

//
// üî• JOB ‚Äî Apura√ß√£o de rodada (OFICIAL)
// Respons√°vel por:
// - Calcular score dos tickets
// - Gerar UserScoreHistory
// - Marcar rodada como SCORED
//
router.post(
  '/jobs/score-round',
  internalJobAuth,
  (req, res) => scoreRoundJobController.execute(req, res)
);

//
// üîπ JOB ‚Äî Snapshot de Ranking v1.2
//
router.post(
  '/jobs/generate-ranking-snapshot',
  internalJobAuth,
  GenerateRankingSnapshotController.handle
);

export default router;
</file>

<file path="src/routes/internal/index.ts">
import { Router } from 'express';
import mercadoPagoRoutes from './mercado-pago.routes';
import subscriptionJobsRoutes from './subscription-jobs.routes';

const router = Router();

router.use(mercadoPagoRoutes);
router.use(subscriptionJobsRoutes);

export default router;
</file>

<file path="src/routes/ranking.routes.ts">
import { Router } from 'express';
import { RankingController } from '../controllers/ranking.controller';
import { MonthlyRankingController } from '../controllers/ranking/monthly-ranking.controller';
import { SemesterRankingController } from '../controllers/ranking/semester-ranking.controller';
import { WeeklyRankingController } from '../controllers/ranking/weekly-ranking.controller';
import { JoinBolaoController } from '../services/bolao/join-bolao.controller';
import { BolaoRankingController } from '../controllers/bolao/bolao-ranking.controller';
import { CreateBolaoInviteController } from '../controllers/bolao/create-bolao-invite.controller';
import { UseBolaoInviteController } from '../controllers/bolao/use-bolao-invite.controller';

const router = Router();
const controller = new RankingController();

//
// üîπ Rankings por per√≠odo (ROTAS ESPEC√çFICAS PRIMEIRO)
//
router.get('/rankings/monthly', MonthlyRankingController.handle);
router.get('/rankings/semester', SemesterRankingController.handle);
router.get('/rankings/weekly', WeeklyRankingController.handle);

//
// üîπ Ranking gen√©rico por ID (SEMPRE POR √öLTIMO)
//
router.get('/rankings/:rankingId', controller.show);

//
// üîπ Entrada direta em bol√£o
//
router.post('/rankings/:rankingId/join', JoinBolaoController.handle);

//
// üîπ Ranking de leitura do bol√£o
//
router.get('/rankings/:rankingId/bolao', BolaoRankingController.handle);

//
// üîπ Convites de bol√£o
//
router.post('/rankings/:rankingId/invites', CreateBolaoInviteController.handle);
router.post('/boloes/invites/:code/join', UseBolaoInviteController.handle);

export default router;
</file>

<file path="src/controllers/internal/mercado-pago-webhook.controller.ts">
import { Request, Response } from 'express';
import { ProcessMpSubscriptionCreatedService } from '../../services/subscription/process-mp-subscription-created.service';
import { ProcessMercadoPagoWebhookService } from '../../services/payment/process-mercado-pago-webhook.service';

export class MercadoPagoWebhookController {
  static async handle(req: Request, res: Response): Promise<Response> {
    const event = req.body;
    const timestamp = new Date().toISOString();

    console.info({
      level: 'INFO',
      service: 'MercadoPagoWebhookController',
      action: 'webhook.received',
      provider: 'MERCADO_PAGO',
      externalEventId: event?.id,
      message: 'Webhook recebido',
      timestamp,
    });

    try {
      if (event?.type === 'subscription') {
        if (event?.action === 'subscription.created') {
          console.info({
            level: 'INFO',
            service: 'MercadoPagoWebhookController',
            action: 'subscription.created',
            externalEventId: event?.id,
            message: 'Processando subscription.created',
            timestamp,
          });

          await ProcessMpSubscriptionCreatedService.execute(event);
        }
      }

      if (event?.type === 'payment') {
        try {
          await ProcessMercadoPagoWebhookService.execute(event);
        } catch {
          console.warn({
            level: 'WARN',
            service: 'MercadoPagoWebhookController',
            action: 'payment.test_ignored',
            paymentId: event?.data?.id,
            message: 'Pagamento de teste ignorado',
            timestamp,
          });
        }
      }

      return res.status(200).json({ received: true });
    } catch (error) {
      console.error({
        level: 'ERROR',
        service: 'MercadoPagoWebhookController',
        action: 'webhook.error',
        message: 'Erro inesperado no webhook',
        error,
        timestamp,
      });

      return res.status(500).json({ error: 'webhook_failed' });
    }
  }
}
</file>

<file path="src/routes/payment.routes.ts">
import { Router } from 'express'
import PaymentController from '../controllers/payment.controller'

const router = Router()

router.post('/api/payments', PaymentController.create)
router.get('/api/payments/history', PaymentController.history)

export default router
</file>

<file path="src/index.ts">
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

/**
 * üîê AUTENTICA√á√ÉO
 */
import authRoutes from './routes/auth';

/**
 * üü¢ ROTAS P√öBLICAS
 */
import userRoutes from './routes/user.routes';
import meRoutes from './routes/me';
import ticketRoutes from './routes/ticket.routes';
import rankingRoutes from './routes/ranking.routes';

/**
 * üõ†Ô∏è ADMIN
 */
import adminMonetizationRoutes from './routes/admin-monetization.routes';
import adminSubscriptionsRoutes from './routes/admin-subscriptions.routes';

/**
 * ‚öôÔ∏è ROTAS INTERNAS
 * - Jobs
 * - Webhooks (Mercado Pago)
 */
import internalRoutes from './routes/internal';

/**
 * ‚ö†Ô∏è ERROR HANDLER
 */
import { errorHandler } from './middleware/error-handler';

dotenv.config();

const app = express();

/**
 * üåê MIDDLEWARES B√ÅSICOS
 * (ORDEM IMPORTA)
 */
app.use(
  cors({
    origin: [
      'https://f12-banco-frontend-f12.x18arx.easypanel.host',
      'http://localhost:5173',
    ],
    credentials: true,
  })
);
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

/**
 * üî¥ LOG GLOBAL ‚Äî PRIMEIRO DE TUDO
 */
app.use((req: Request, _res: Response, next: NextFunction) => {
  console.log(`[REQ] ${req.method} ${req.url}`);
  next();
});

/**
 * üü¢ ROTAS P√öBLICAS / API
 */
app.use('/api', ticketRoutes);
app.use('/api', userRoutes);
app.use('/api', rankingRoutes);
app.use('/api', meRoutes);

/**
 * üîê AUTENTICA√á√ÉO
 */
app.use('/auth', authRoutes);

/**
 * ‚öôÔ∏è ROTAS INTERNAS
 * - jobs
 * - webhooks (Mercado Pago)
 */
app.use('/internal', internalRoutes);

/**
 * üõ†Ô∏è ADMIN ‚Äî MONETIZA√á√ÉO
 */
app.use('/api', adminMonetizationRoutes);

/**
 * üõ†Ô∏è ADMIN ‚Äî ASSINATURAS (v1.6)
 */
app.use('/api', adminSubscriptionsRoutes);

/**
 * ‚ù§Ô∏è HEALTHCHECK
 */
app.get('/health', (_req, res) => {
  res.json({ api: 'ok', db: 'ok' });
});

/**
 * üìç ROOT
 */
app.get('/', (_req, res) => {
  res.json({
    name: 'Fantasy12 API',
    status: 'running',
    timestamp: new Date().toISOString(),
  });
});

const PORT = Number(process.env.PORT ?? 3001);

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Fantasy12 API rodando na porta ${PORT}`);
});

/**
 * ‚ö†Ô∏è ERROR HANDLER ‚Äî SEMPRE √öLTIMO
 */
app.use(errorHandler);
</file>

<file path="prisma/schema.prisma">
// ======================
// PRISMA CONFIG
// ======================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ======================
// ENUMS
// ======================

enum UserRole {
  ADMIN
  PRO
  NORMAL
}

enum RoundStatus {
  DRAFT
  PENDING
  OPEN
  CLOSED
  SCORED
  CANCELLED
}

enum TicketStatus {
  PENDING
  WON
  LOST
}

enum RankingType {
  GLOBAL
  PRO
  BOLAO
}

enum RankingStatus {
  DRAFT
  ACTIVE
  CLOSED
}

enum SubscriptionPlan {
  MONTHLY
  ANNUAL
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
}

enum WalletTransactionType {
  CREDIT
  DEBIT
}

// ======================
// ENUMS ‚Äî PAGAMENTO
// ======================

enum PaymentStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  PIX
  CARD
}

enum PaymentProvider {
  MERCADO_PAGO
}

// ======================
// USER
// ======================
model User {
  id               String   @id @default(uuid())
  name             String
  email            String   @unique
  password         String
  role             UserRole @default(NORMAL)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  nickname         String?  @unique
  cpf              String?  @unique
  profileImage     String?
  bio              String?
  phone            String?

  tickets          Ticket[]
  rankings         RankingParticipant[]
  auditLogs        AuditLog[]
  scoreHistory     UserScoreHistory[]
  rankingSnapshots RankingSnapshot[]

  createdBolao     Ranking[] @relation("BolaoCreator")

  subscription     Subscription?
  wallet           Wallet?
  roundBenefits    RoundBenefit[]
  bolaoInvites     BolaoInvite[]
  payments         Payment[]

  @@map("users")
}

// ======================
// ROUND
// ======================
model Round {
  id               String      @id @default(uuid())
  number           Int         @unique
  status           RoundStatus @default(DRAFT)
  openAt           DateTime?
  closeAt          DateTime?
  result           String?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  tickets          Ticket[]
  rankings         RankingRound[]
  scoreHistory     UserScoreHistory[]
  rankingSnapshots RankingSnapshot[]
  roundBenefits    RoundBenefit[]

  @@map("rounds")
}

// ======================
// TICKET
// ======================
model Ticket {
  id          String       @id @default(uuid())
  userId      String
  roundId     String
  prediction  String
  status      TicketStatus @default(PENDING)
  scoreRound  Int          @default(0)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  user        User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  round       Round @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@unique([userId, roundId])
  @@index([userId])
  @@index([roundId])
  @@map("tickets")
}

// ======================
// USER SCORE HISTORY
// ======================
model UserScoreHistory {
  id          String   @id @default(uuid())
  userId      String
  roundId     String
  scoreRound  Int
  scoreTotal  Int
  createdAt   DateTime @default(now())

  user        User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  round       Round @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@unique([userId, roundId])
  @@index([userId])
  @@index([roundId])
  @@map("user_score_history")
}

// ======================
// RANKING
// ======================
model Ranking {
  id                  String        @id
  name                String        @unique
  description         String?
  type                RankingType
  status              RankingStatus @default(DRAFT)

  startDate           DateTime?
  endDate             DateTime?

  maxParticipants     Int?
  currentParticipants Int           @default(0)
  durationDays        Int?

  createdByUserId     String?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  participants        RankingParticipant[]
  rounds              RankingRound[]
  invites             BolaoInvite[]

  createdBy User? @relation("BolaoCreator", fields: [createdByUserId], references: [id])

  @@map("rankings")
}

// ======================
// RANKING PARTICIPANT
// ======================
model RankingParticipant {
  id           String   @id @default(uuid())
  rankingId    String
  userId       String
  score        Int      @default(0)
  scoreInitial Int      @default(0)
  position     Int?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  ranking      Ranking @relation(fields: [rankingId], references: [id], onDelete: Cascade)
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([rankingId, userId])
  @@index([rankingId])
  @@index([userId])
  @@map("ranking_participants")
}

// ======================
// RANKING ROUND
// ======================
model RankingRound {
  id        String   @id @default(uuid())
  rankingId String
  roundId   String
  createdAt DateTime @default(now())

  ranking   Ranking @relation(fields: [rankingId], references: [id], onDelete: Cascade)
  round     Round   @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@unique([rankingId, roundId])
  @@index([rankingId])
  @@index([roundId])
  @@map("ranking_rounds")
}

// ======================
// AUDIT LOG
// ======================
model AuditLog {
  id        String   @id @default(uuid())
  userId    String?
  action    String
  entity    String
  entityId  String?
  metadata  Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  user      User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([entity])
  @@index([createdAt])
  @@map("audit_logs")
}

// ======================
// RANKING SNAPSHOT
// ======================
model RankingSnapshot {
  id           String   @id @default(uuid())
  roundId      String
  userId       String

  scoreTotal   Int
  scoreRound   Int
  position     Int

  snapshotType String
  periodRef    String?

  createdAt    DateTime @default(now())

  round        Round @relation(fields: [roundId], references: [id], onDelete: Cascade)
  user         User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([roundId, userId])
  @@index([roundId])
  @@index([userId])
  @@index([roundId, scoreTotal])
  @@map("ranking_snapshots")
}

// ======================
// SUBSCRIPTION
// ======================
model Subscription {
  id        String             @id @default(uuid())
  userId    String             @unique
  plan      SubscriptionPlan
  status    SubscriptionStatus @default(ACTIVE)

  startAt   DateTime
  endAt     DateTime?

  // üîπ v1.5 ‚Äî recorr√™ncia
  provider                PaymentProvider?
  externalSubscriptionId  String?
  externalCustomerId      String?
  
  packageId               String?          @db.Text
  package                 PaymentPackage?  @relation(fields: [packageId], references: [id])

  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("subscriptions")
}

// ======================
// WALLET
// ======================
model Wallet {
  id        String   @id @default(uuid())
  userId    String   @unique
  balance   Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  ledger    WalletLedger[]

  @@map("wallets")
}

// ======================
// WALLET LEDGER
// ======================
model WalletLedger {
  id          String                  @id @default(uuid())
  walletId    String
  type        WalletTransactionType
  amount      Int
  description String?

  createdAt   DateTime @default(now())

  wallet      Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId])
  @@map("wallet_ledger")
}

// ======================
// ROUND BENEFITS (FREE)
// ======================
model RoundBenefit {
  id               String   @id @default(uuid())
  userId           String
  roundId          String

  freeDoubles      Int      @default(0)
  freeSuperDoubles Int      @default(0)

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  round            Round @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@unique([userId, roundId])
  @@index([roundId])
  @@map("round_benefits")
}

// ======================
// BOLAO INVITE
// ======================
model BolaoInvite {
  id              String   @id @default(uuid())
  rankingId       String
  code            String   @unique

  maxUses         Int?
  usedCount       Int      @default(0)

  expiresAt       DateTime?
  isActive        Boolean  @default(true)

  createdByUserId String
  createdAt       DateTime @default(now())

  ranking         Ranking @relation(fields: [rankingId], references: [id], onDelete: Cascade)
  createdBy       User    @relation(fields: [createdByUserId], references: [id], onDelete: Cascade)

  @@index([rankingId])
  @@index([code])
  @@map("bolao_invites")
}

// ======================
// PAYMENT PACKAGE
// ======================
model PaymentPackage {
  id          String   @id @db.Text
  label       String
  coinsAmount Int
  amountCents Int
  bonusCoins  Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  payments    Payment[]
  subscriptions Subscription[] 

  @@map("PaymentPackage")
}


// ======================
// PAYMENT
// ======================
model Payment {
  id                String          @id @db.Text

  userId            String          @db.Text
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  provider          PaymentProvider
  method            PaymentMethod
  status            PaymentStatus   @default(PENDING)

  packageId         String        @db.Text
  package           PaymentPackage @relation(fields: [packageId], references: [id])


  amountCents       Int
  coinsAmount       Int
  bonusCoins        Int           @default(0)

  externalPaymentId String?         @unique @db.Text
  externalReference String?         @unique @db.Text

  isCredited        Boolean         @default(false)

  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([userId])
  @@index([status])
  @@index([packageId])
  @@map("payments")
}

// ======================
// PAYMENT WEBHOOK EVENT
// ======================
model PaymentWebhookEvent {
  id              String           @id @db.Text
  provider        PaymentProvider
  externalEventId String           @db.Text
  payload         Json
  receivedAt      DateTime         @default(now())

  @@unique([provider, externalEventId])
  @@map("payment_webhook_events")
}
</file>

</files>
